CLR_LCD    			MACRO									; CLEAR LCD
        			MOV     	A, #01H
       				LCALL   	LCD_CMD																			
           			ENDM  
; --------------------------------------------------------------------------------------------------------------------------------------
D_STR     			MACRO									; DISPLAY STRINGS OF CHARACTER
       				LCALL    	LCD_CMD
        			LCALL    	DISP_CHAR
           			ENDM
//; ========================================================  MAIN  ======================================================================
//					ORG			0000H
//					JMP			MAIN						; ON SYSTEM RESET, JUMP TO MAIN
//					
//					ORG			0003H
//					JMP			SECOND_FUNCTION				; ON SYSTEM EXTERNAL INTERRUPT 0, JUMP TO THE ISR 'SECOND_FUNCTION'
//
//					ORG			0030H
//MAIN:														; THE MAIN PROGRAM BEGINS HERE
//					MOV			SP, #57H					; INITIALIZATION OF THE TOP OF THE STACK(40 BYTES OF MEM. ARE AVAILABLE ON THIS INITIALIZATION)
//					MOV 		P1,#0FFH					; MAKE PORT1 AN INPUT PORT
//					MOV 		P3, #00001000B
//					LCALL 		LCD_SET						; SET THE LCD FOR PROPER PERFORMANCE
//					LCALL		INTRO_MSG					; CALLS AN OSR TO DISPLAY LINE 1: '   SBC 8085uP   '
//															;                         LINE 2: 'by IFEDIORA E.C.'  OR 'by FEDYRONIX INC'
//MAIN1:				CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED TO CONTINUE
//					JNB			01H, MAIN1
//					CLR			01H							; GET READY FOR NEXT KEY
//															
//					CLR_LCD									; CLEAR THE LCD (NOTE THIS RESET THE ADDRESS OF THE DDRAM TO 80H
//					LCALL		INTRO_CPU_TYPE				; CALLS AN OSR TO DISPLAY LINE 1: 'Press 3 for 8085'
//															;                         LINE 2: 'Press 4 for 8051' 
//MAIN1_1:			CALL		KEYPAD_ID					; ENSURE THAT EITHER '3' OR '4' KEY IS DEPRESSED
//					JNB			01H, MAIN1_1
//					CLR			01H							; GET READY FOR NEXT KEY
//
//					CJNE		A, #'3', MAIN1_2
//					CLR			0DH							; SELECTS 8085 CPU INSTRUCTION SET
//					SJMP		MAIN1_3
//MAIN1_2:			CJNE		A, #'4', MAIN1_1
//					SETB		0DH							; SELECTS 8051 CPU INSTRUCTION SET
//																				
//
//					CLR_LCD									; CLEAR THE LCD (NOTE THIS RESET THE ADDRESS OF THE DDRAM TO 80H
//					LCALL		INTRO_CPLT					; CALLS AN OSR TO DISPLAY LINE 1: 'Press 0 for MHEX'
//															;                         LINE 2: 'Press 1 for ASM' 
//MAIN1_3:			CALL		KEYPAD_ID					; ENSURE THAT EITHER '0' OR '1' KEY IS DEPRESSED
//					JNB			01H, MAIN1_3
//					CLR			01H							; GET READY FOR NEXT KEY
//
//					CJNE		A, #'0', MAIN1_4
//					CLR			09H							; SELECTS MHEX
//					MOV			3BH, #02H					; MOVE '2' INTO THE MHEX COUNTER
//					SJMP		MAIN1_5
//MAIN1_4:			CJNE		A, #'1', MAIN1_3
//					SETB		09H							; SELECTS ASM
//
//MAIN1_5:			MOV 		IE, #10000001B				; ENABLE THE !INT0 EXTERNAL INTERRUPT (SECOND_FUNCTION ISR)
//
//					CLR_LCD
//					LCALL		INTRO_SUBMEM_REQUEST		; CALLS AN OSR TO DISPLAY ON LINE 1: 'Enter start addr'
//
//					MOV			30H,#04H					; LOAD '4' INTO THE COUNTER 
//					JNB			00H, $						; STAY HERE TILL THE SUB MEM IS PRESSED
//
//					; 8085 OR 8051?
//					JB			0DH, ___8051				; IF 0DH = 1 (8051) JUMP TO 8051 ASM INSTR. SET ELSE CONTINUE WITH 8085 ASM INSTR. SET
//
//					JNB			09H, M_HEX					; USE MACHINE LANGUAGE FOR 09H = 0 ELSE USE ASM FOR 09H = 1
//					JMP			MAIN2
//; ----------------------------------------------------------------------------------------------------------------------------------
//___8051:			
//					;JNB			09H, M_HEX						; USE MACHINE LANGUAGE FOR 09H = 0 ELSE USE ASM FOR 09H = 1
//					D_STR									; A LCD SCREEN CLEAR THUS DDRAM ADDRESS AUTOMATICALLY RESETS TO LINE 1
//					DB			'8051 LOOP YES',0		; LINE 1
//					JMP			$
//; ----------------------------------------------------------------------------------------------------------------------------------


; =*=*=*=*=*=*=*=*=*=*=*=*=*   MACHINE LANGUAGE (IN HEX, MHEX) AS THE CODE/PROGRAMMING LANGUAGE TYPE (CPLT)  =*=*=*=*=*=*=*=*=*=*=*=*=*=
; THIS MANIS SEGMENT/SUBROUTINE IS DEDICATED FOR MHEX
; THE CHOICE WOULD ALWAYS BE BETWEEN MACHINE LANGUAGE (IN HEX, MHEX) AND ASSEMBLY LANGUAGE (ASM)
; A TEST FLAG SHOULD COME AFTER SUB MEM FLAG IN THE MAIN PROGRAM
	  
; --------------------------------------------------------------------------------------------------------------------------------------
			   	ORG			00
				SJMP		FEDY


				ORG			30H
FEDY:
				MOV 		P1,#0FFH					; MAKE PORT1 AN INPUT PORT
				MOV 		P3, #00001000B

   				ACALL 		LCD_SET
				MOV     	A, #01H
   				LCALL   	LCD_CMD

				MOV			3BH, #02H					; MOVE '2' INTO THE MHEX COUNTER

				MOV			39H, #00H
				MOV			3AH, #20H
				CALL		ADDRESS_DISPLAY_CONTROL			; CALL THIS OSR TO CLEAR THE LCD SCREEN AND WRITE THE NEW ADDRESS IN LINE 1
			//	LCALL		INTRO_SUBMEM_REQUEST		; CALLS AN OSR TO DISPLAY ON LINE 1: 'Enter start addr'

M_HEX:			
; ELOO PLEASE INCLUDE THE INSTRUCTIONS TO CARRY OUT DISPLAY ON LINE 2 HERE
				CALL		KEYPAD_ID						; ENSURE A KEY(1ST KEY) IS DEPRESSED
				JNB			01H, M_HEX
				CLR			01H								; GET READY FOR NEXT KEY
				MOV			31H, A

				CJNE		A, #30H, MH_1					; THE CONTENT OF 'A' MUST SATISFY THE FOLLOWING INEQUALITY: 30H =< A =< 46H
				CLR			C								; ENSURE IT PASSES TO THE NEXT INSTRUCTION

MH_1:			JC			M_HEX							; IF A > 30 CONTINUE ELSE GO BACK TO MHEX
				SUBB		A, #30H 						; SUBTRACT 30H FROM A REGISTER
				CJNE		A, #0AH, MH_2					
				CLR			C 								; ENSURE IT PASSES TO THE NEXT INSTRUCTION

MH_2:			JC			MH_4
				SUBB		A, #07H							; SUBTRACT 07H FROM 'A' REGISTER
				CJNE		A, #0FH, MH_3					; CHECK IF THE RESULT OF THE SUBTRACTION IS GREATER THAN 0FH; IF SO EXIT THE SR ELSE CONTINUE
				SETB		C								; ENSURE IT PASSES TO THE NEXT INSTRUCTION

MH_3:			JNC			M_HEX							; START AFRESH (ie MHEX) IF THE KEYPAD INPUT DOES NOT SATISFY THE ABOVE INEQUALITY
															; ELSE CONTINUE
MH_4:			CPL			0AH								; FORMAT THE DATA AND SAVE TEMPORARILY IN THE MEM LOC 33H
				JNB			0AH, MH_5
				SWAP		A
				MOV			33H, A							
				SJMP		MH_6							; SKIP OPERATIONS IN LABEL MHEX_5

MH_5:			ORL			A, 33H							; FORMAT COMPLETED
				MOV			33H, A							; CARRY OUT THE FINAL SAVE
				
MH_6:			MOV			A, 31H							; LOAD THE ASCII CODE FOR THE CURRENT CHARARTER TO BE DISPLAYED
				CALL		LCD_SHO

				DJNZ		3BH, M_HEX						; DECREMENT AND JUMP TILL ZERO TO CONTINUE

MH_7:			CALL		KEYPAD_ID						; ENSURE A KEY IS DEPRESSED
				JNB			01H, MH_7
				CLR			01H	

				CJNE		A, #'*', MH_7					; WAIT FOR 'NEXT KEY' TO BE PRESSED

				MOV			3BH, #02H						; LOAD ANOTHER TWO DIGIT COUNT INTO MHC FOR THE NEXT INPUT (INSTRUCTION SET)

				CLR			03H								; SELECT OPCODE TYPE IN THE 'NEXT SR'
				CALL		NEXT							; CALL NEXT OSR TO PERMANENTLY SAVE THE HEX CODE IN THE EXTERNAL MEMORY
				CALL		ADDRESS_DISPLAY_CONTROL			; CALL THIS OSR TO CLEAR THE LCD SCREEN AND WRITE THE NEW ADDRESS IN LINE 1

				AJMP		M_HEX							

				
ADDRESS_DISPLAY_CONTROL:
; THIS SR IS USED BY FLY_OPCODE & FLY_OPERAND (ie DATA TYPE & ADDRESS TYPE) TO CONTROL THE ADDRESS DISPLAY IN LINE 1
; WHENEVER ENTRY IN LINE 2 IS COMPLETE AND NEXT IS PRESSED.
; ALSO IT IS USED BY V_HEX AND CANCEL SR TO CONTROL THE ADDRESS DISPLAY IN LINE 1
; THE INPUT MEMORY LOCATIONS TO THIS SUBROUTINE ARE 3AH & 39H

; IT FIRST CLEARS THE SCREEN OF THE LCD BEFORE WRITING INTO ITS LINE 1 ONLY. ALSO INCLUDE ':' AFTER THE ADDRESS

				MOV     	A, #01H
       			LCALL   	LCD_CMD

				; MOST SIGNIFICANT BYTE (MSB)
				MOV			36H, 3AH				; PLACE THE HOB OF THE CURRENT ADDRESS INTO THE INPUT MEMORY LOC. (36H) OF H2A SR
				CALL		HEX_2_ASCII

				MOV			A, #80H					; LOAD A COMMAND TO DISPLAY THE CONTENT OF 38H & 37H ON LINE 1, POSITION 1 & 2
				CALL		LCD_CMD

				MOV			A, 38H					; 1ST NIBBLE DISPLAYED IN HEX IN POSITION 1
				CALL		LCD_SHO

				MOV			A, 37H					; 2ND NIBBLE DISPLAYED IN HEX IN POSITION 2
				CALL		LCD_SHO

				; LEAST SIGNIFICANT BYTE (LSB)
				MOV			36H, 39H				; PLACE THE HOB OF THE CURRENT ADDRESS INTO THE INPUT MEMORY LOC. (36H) OF H2A SR
				CALL		HEX_2_ASCII

				MOV			A, 38H					; 3RD NIBBLE DISPLAYED IN HEX IN POSITION 3
				CALL		LCD_SHO

				MOV			A, 37H					; 4TH (LAST) NIBBLE DISPLAYED IN HEX IN POSITION 4
				CALL		LCD_SHO


				MOV			A, #':'					; DISPLAY ':' PROBABLY ON LINE 1, POSITION 5 (SINCE FOUR DISPLAYS HAS BEEN CARRIED OUT)
				CALL		LCD_SHO

				MOV     	A, #0C0H
   				LCALL   	LCD_CMD
				RET

HEX_2_ASCII:
; THIS A SR THAT TAKES CARE OF GENERATING THE EQUIVALENT ASCII CODE FROM A HEX INPUT CODE
				; HIGH ORDER BYTE CONVERSION BEGINS	HERE
				MOV			A, 36H					; LOAD THE HEX BYTE TO BE CONVERTED INTO 'A'
				ANL			A, #0F0H				; MASK THE LOW ORDER BYTE
				SWAP		A						; HOB <==> LOB
				CJNE		A, #0AH, H2A_1
				CLR			C
													; IF 'A' >= 0AH	DO THE FOLLOWING INSTRUCTIONS
H2A_1:			JC			H2A_2					; ADD 07H & LATER 30H 
				ADD			A, #07H					; (RAISE THE CONTENT OF 'A' TO THE NUMERICAL VALUE OF ITS EQUIVALENT ASCII CODE)

													; IF 'A' < 0AH DO THE FOLLOWING INSTRUCTIONS
H2A_2:			ADD			A, #30H				   	; ADD 30H (RAISE THE CONTENT OF 'A' TO THE NUMERICAL VALUE OF ITS EQUIVALENT ASCII CODE) 

				MOV			38H, A					; SAVE THE ASCII CODE OF THE HIGH ORDER BYTE IN MEM. 38H
													; HIGH ORDER BYTE CONVERSION ENDS HERE

				; LOW ORDER BYTE CONVERSION BEGINS HERE
				MOV			A, 36H					; LOAD THE HEX BYTE TO BE CONVERTED INTO 'A'
				ANL			A, #0FH					; MASK THE HIGH ORDER BYTE
				CJNE		A, #0AH, H2A_3
				CLR			C
													; IF 'A' >= 0AH	DO THE FOLLOWING INSTRUCTIONS
H2A_3:			JC			H2A_4					; ADD 07H & LATER 30H 
				ADD			A, #07H					; (RAISE THE CONTENT OF 'A' TO THE NUMERICAL VALUE OF ITS EQUIVALENT ASCII CODE)

													; IF 'A' < 0AH DO THE FOLLOWING INSTRUCTIONS
H2A_4:			ADD			A, #30H				   	; ADD 30H (RAISE THE CONTENT OF 'A' TO THE NUMERICAL VALUE OF ITS EQUIVALENT ASCII CODE) 

				MOV			37H, A					; SAVE THE ASCII CODE OF THE LOWER ORDER BYTE IN MEM. 37H

													; LOW ORDER BYTE CONVERSION ENDS HERE
				RET

; TESTED: QC PASSED SYNTAXICALLY AND SEMANTICALLY

; --------------------------------------------------------------------------------------------------------------------------------------
; THIS SUBROUTINE LOADS THE APPROPRIATE OPCODE OR OPERAND(ie DATA OR ADDRESS) INTO THEIR PERMANENT LOCATION
; IT DIFFRENETIATES OPCODE CALL FROM AN OPERAND CALL BY USING THE NEXT TYPE FLAG (ie NCF 03H)
; WHEN IT IS SET IT CALLS THE OPERAND ELSE THE OPCODE, NCF IS TESTED AT THE ENTRANCE TO THE SR 
; IT ALSO HANDLES THE SUB MEM START ADDRESS INTIALIZATION 

; THIS IS THE SR WHERE MEMORY ADDRESS INCREMENT DISPLAY REGISTER IS TO BE CONFIGURED
; ***ON ERROR AFTER TESTING THIS SR CHANGE DPH = 83H, & DPL = 82H(DIRECT ADDRESSING)

; ****REMEMBER TO SAVE REGS & FLAGS STILL RELEVANT TO THE CALLER PROGRAM TO AVOID DATA LOSS****

NEXT:			

				JB			08H, NEXT_4_SUB_MEM		   	; CHECK WHETHER CALLER PROGRAM IS SUB MEM OR OTHERS AND JUMP APTLY
				SJMP		NEXT_4_OPCODE
NEXT_4_SUB_MEM:
				; LOAD THE USER'S DESIRED START CODE ADDRESS IN THE DATA POINTER'S HIGH AND LOWER ORDER REG.
				

				MOV			3AH, 35H					; LOAD THE HIGH ORDER BYTE INTO NEXT ADDRESS HOLDER/ADDRESS_DISPLAY_CONTROL'S INPUT MEM LOC 2 FOR DISPLAY 
				MOV			39H, 34H					; LOAD THE LOW ORDER BYTE INTO NEXT ADDRESS HOLDER/ADDRESS_DISPLAY_CONTROL'S INPUT MEM LOC 1 FOR DISPLAY

				MOV			3FH, 35H					; LOAD THE HIGH ORDER BYTE INTO THE V_HEX DISPLAY ADDRESS MEM LOC 2
				MOV			3EH, 34H					; LOAD THE LOWER ORDER BYTE	INTO THE V_HEX DISPLAY ADDRESS MEM LOC 1

				MOV			43H, 35H					; SAVE THE CURRENT ADDRESS IN THE PAGE MEMORY (HOB)
				MOV			42H, 34H					;											  (LOB)

				MOV			41H, 35H				   	; THE END ADDRESS (PREPARE AN ADDRESS +1 GREATER THAN ITSELF) FOR AUTO EXAM REG... 
				MOV			40H, 34H				   	; BY BOTH THE uC AND uP AFTER 'END' IS PRESSED

				; THE MEM. LOCATIONS TO BE USED HERE ARE 34H & 35H (BECAUSE THEY CONTAIN THE CURRENT LOW & HIGH ORDER ADDRESS RESPECTIVELY)
				; LOAD IT INTO A REGISTER (EXTERNAL TRANSFER REGISTER) THAT CAN COMMUNICATE WITH THE OUTSIDE WORLD(I MEAN OUTSIDE THE MICROCONTROLLER)

				CLR			08H							; CLEAR THE NEXT SUB MEM FLAG (IS IT NECESSARY TO CLEAR THIS FLAG OR JUST LEAVE IT TO CLEAR ON RESET)
				SJMP		EXIT_NEXT					; ELOO CHECK AGAIN COS I THINK IT IS NECESSARY TO BE CLEARED ON MY FIRST LOOK/REVIEW 
NEXT_4_OPCODE:
				PUSH		DPH							; SAVE THE CONTENT OF THE DATA POINTER REGISTERS SINCE THEY WOULD BE USED HERE
				PUSH		DPL

				MOV			DPH, 3AH					; LOAD THE PREVIOUS ADDRESS INTO THE DATA POINTER
				MOV			DPL, 39H

				MOV			41H, DPH				   	; LOAD THE PREVIOUS ADDRESS INTO THE END ADDRESS WHICH PREPARE AN ADDRESS... 
				MOV			40H, DPL				   	; +1 GREATER THAN ITSELF FOR AUTO EXAM REG BY BOTH THE uC & uP AFTER 'END' IS PRESSED

				JB 			03H, NEXT_OPERAND			; SELECT BETWEEN OPERAND AND OPCODE NEXT CALL (OPCODE TYPE 03H= 0, OPERAND TYPE 03H= 1)

				; OPCODE NEXT CALL BEGINS HERE

				MOV			A, 33H						; TRANSFER THE OPCODE'S HEX CODE FROM BYTE 1 TEMPORARY STORE (ie 33H)
				MOVX		@DPTR, A					; INTO THE EXTERNAL MEMORY SPECIFIED BY THE USER.
				INC			DPTR						; INCREMENT THE DATA POINTER FOR THE NEXT INSTRUCTION'S EXTERNAL TRANSFER

				SJMP		EXIT_NEXT					; 'NEXT SR' CALL ENDS HERE FOR THE OPCODE
NEXT_OPERAND:	
				JB			0DH, NEXT_OPERAND_AD_TYPE	; JUMP TO THE LABEL IF IT IS CALL BY 8051
___8051_SPECIAL_NEXT:
				; THE DATA TYPE OR BYTE 2 OPERAND(LOW ADDRESS BYTE) BEGINS HERE (FOR 8085)
				MOV			41H, DPH				   	; LOAD THE PREVIOUS ADDRESS INTO THE END ADDRESS WHICH PREPARE AN ADDRESS... 
				MOV			40H, DPL				   	; +1 GREATER THAN ITSELF FOR AUTO EXAM REG BY BOTH THE uC & uP AFTER 'END' IS PRESSED

				MOV			A, 34H						; TRANSFER THE OPCODE'S HEX CODE FROM BYTE 2 TEMPORARY STORE (ie 34H)
				MOVX		@DPTR, A					; INTO THE EXTERNAL MEMORY SPECIFIED BY THE USER.
				INC			DPTR						; INCREMENT THE DATA POINTER FOR THE NEXT INSTRUCTION'S EXTERNAL TRANSFER
				
				JB			0DH, EXIT_NEXT

				JB			07H, NEXT_OPERAND_AD_TYPE	; SELECT BETWEEN DATA AND ADDRESS TYPE OPERAND (FOR 8085 HERE)
														; THE DATA TYPE CONTINUES WHILE ADDRESS TYPE JUMPS
				SJMP		EXIT_NEXT					; SR ENDS HERE FOR THE DATA TYPE OPERAND

NEXT_OPERAND_AD_TYPE:
				; ADDRESS TYPE COMPLETES THE REMAINING HALF (ie BYTE 3)
				MOV			41H, DPH				   	; LOAD THE PREVIOUS ADDRESS INTO THE END ADDRESS WHICH PREPARE AN ADDRESS... 
				MOV			40H, DPL				   	; +1 GREATER THAN ITSELF FOR AUTO EXAM REG BY BOTH THE uC & uP AFTER 'END' IS PRESSED

				MOV			A, 35H						; TRANSFER THE OPCODE'S HEX CODE FROM BYTE 3 TEMPORARY STORE (ie 35H)
				MOVX		@DPTR, A					; INTO THE EXTERNAL MEMORY SPECIFIED BY THE USER.
				INC			DPTR						; INCREMENT THE DATA POINTER FOR THE NEXT INSTRUCTION'S EXTERNAL TRANSFER
				
				JNB			0DH, EXIT_NEXT				; END TO ALL 8085 ACTIVITIES
				JB			0EH, ___8051_SPECIAL_NEXT	; SELECT BETWEEN DATA(0EH=0) AND ADDRESS(0EH=1) TYPE OPERAND (FOR 8051 HERE)
														; TO STOP DATA OPERAND FROM JUMPING (FOR 8051)

EXIT_NEXT:		; SAVE THE NEXT INSTRUCTION'S EXTERNAL TRANSFER ADDRESS (CURRENT ADDRESS)
				MOV			3AH, DPH					; LOAD THE HIGH ORDER BYTE
				MOV			39H, DPL					; LOAD THE LOWER ORDER BYTE

;				MOV			43H, 3AH					; SAVE THE CURRENT ADDRESS IN THE PAGE MEMORY (HOB)
;				MOV			42H, 39H					;											  (LOB)

				; DISPLAY THE NEW ADDRESS IN LINE 1 OF THE LCD (THE NEW ADDRESS ARE IN THE MEM LOC. 39H & 3AH)
				POP     	DPL							; RETRIEVE THE FORMER CONTENT OF THE DATA POINTER REGISTER
	       		POP     	DPH							; REMEMBER 'FIFO' TECHGNIQUE IS USED WHEN PUSHING AND POPPING ON THE STACK
				
				RET


//INTRO_SUBMEM_REQUEST:
//;				
//				//	LCALL    	LCD_CMD
//        			LCALL    	DISP_CHAR								; DISPLAY THE FOLLOWING STRINGS 
//					DB			'Enter Start Addr',0		; LINE 1
//					RET
////
////; ---------------------------------------------------------------------------------------------------------------------------------------
//DISP_CHAR:
//        			POP     	DPH
//        			POP     	DPL
//PRINT_TEXT:
//        			CLR     	A
//        			MOVC    	A, @A+DPTR
//       				CJNE    	A, #00H, LOOP
//       				SJMP    	RETURN
//LOOP:  				LCALL  		LCD_SHO
//        			INC     	DPTR
//        			LJMP    	PRINT_TEXT
//RETURN: 			MOV     	A, #01H
//        			JMP     	@A+DPTR

; ---------------------------------------------------------------------------------------------------------------------------------------

; ELOO U MAY PUT UR FLAG FOR SUB MEM ASCII_2_HEX SR CALL HERE(NOTE SUCH FLAG MUST BE CLEAR AT THE SUB MEM SR ON RETURN IMMEDIATELY)
; EXPECTED FLAG INSTRUCTION: JB		SubMem'sAscii2hexFlag, EXIT_A2H

; THE TEST IS COMPLETED. THE INEQUQLITY: 30H =< A =< 46H HAS BEEN SATISFIED AND CONVERSION HAS TAKEN PLACE!!!

; THIS SUBROUTINE RETRIEVES DATA FROM THE KEYPAD AND IDENTIFIES THE KEY PRESSED

//       				EN 			BIT P3.3 					; 
//       				RS 			BIT P2.5
			

//					MOV 		P1,#0FFH					; MAKE PORT1 AN INPUT PORT
//					MOV 		P3, #00001000B
//       				ACALL 		LCD_SET

//M1:					CALL   		KEYPAD_ID
//					SJMP   		M1
       
KEYPAD_ID:			ACALL 		LCD_DLY						; 20mS KEYBOARD/PAD DEBOUNCER
        			MOV 		A, P1
       				CJNE 		A, #11111111B, K_ID_1
					JMP   		KEYFNL
       
K_ID_1: 	 		ACALL 		LCD_DLY						; 20mS KEYBOARD/PAD DEBOUNCER
		       		MOV 		A, P1
       				CJNE 		A, #11111111B, K_ID_2
					JMP 	  	KEYFNL
       
K_ID_2:				MOV 		P3, #11111110B
       				MOV 		A, P1
       				CJNE 		A, #11111111B, ROW_0
       
       				MOV 		P3, #11111101B
       				MOV 		A, P1
       				CJNE 		A, #11111111B, ROW_1
       
       				MOV 		P3, #11101111B
       				MOV 		A, P1
       				CJNE 		A, #11111111B, ROW_2
       
       				MOV 		P3, #11011111B
   					MOV 		A, P1
					CJNE 		A, #11111111B, ROW_3
      
					JMP 	  	KEYFNL
       
ROW_0: 				MOV 		DPTR, #LT_ROW_1
       				SJMP 		K_ID_3						; FIND ROW 1
	
ROW_1:		 		MOV 		DPTR, #LT_ROW_2
       				SJMP 		K_ID_3						; FIND ROW 2

ROW_2: 				MOV 		DPTR, #LT_ROW_3
       				SJMP 		K_ID_3						; FIND ROW 3

ROW_3: 				MOV 		DPTR, #LT_ROW_4
															; FIND ROW 4
K_ID_3: 			RRC 		A
      				JNC 		K_ID_4						; MATCH
      				INC 		DPTR
      				SJMP 		K_ID_3
      
K_ID_4:				ACALL 		LCD_DLY						; THIS SR IS TO ENSURE THAT THE USER RELEASES THE KEY TO AVOID KEY REPETITION
					MOV 		P1,#0FFH					; MAKE PORT 1 AN INPUT PORT
					MOV 		P3, #00001000B
					MOV 		A, P1
       				CJNE 		A, #11111111B, K_ID_4
					
					CLR 		A
       				MOVC 		A, @A+DPTR
	        	//	ACALL 		LCD_SHO
					SETB		01H
					
KEYFNL:	   			RET										; RETURN TO KEYPAD_ID
       
; ---------------------------------------------------------------------------------------------------------------------------------------
GET_READY:
; THIS SUBROUTINE CHECKS BUSY FLAG (P0.7=D7) TO ENABLE COMMAND OR DATA LATCH-IN
; SFR BITS: P0.7 (D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
					SETB 		P0.7 						; MAKE P0.7 INPUT PORT
					CLR 		P2.5	 					; RS=0 ACCESS LCD COMMAND REG
					SETB 		P2.6 						; R/W=1 READ COMMAND REG
															; READ COMMAND REG AND CHECK BUSY FLAG
BACK:	
					CLR 		P3.3	 					; E=0 L-TO-H PULSE
					SETB 		P3.3 						; E=1 FOR L-TO-H PULSE
					JB 			P0.7, BACK					; STAY UNTIL BUSY FLAG=0
					RET										; RETURN TO THE CALLER PROGRAM

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_CMD:
; THIS SUBROUTINE SENDS THE ASCII CODE FOR THE COMMAND CHARATER TO BE DISPLAYED ON THE LCD
; IT CALLS READY (OSR) TO CHECK BUSY FLAG FOR COMMAND TO BE LATCHED-IN
; OPERATING REGISTER: A
; SFR BITS: P0 (LCD DATA PORT D0-D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
 
					ACALL 		GET_READY 					; IS LCD READY?
					MOV   		P0, A						; LATCH COMMAND INTO LCD DATA PORT	  
					CLR   		P2.5						; RS=0 ACCESS LCD COMMAND REG
					CLR			P2.6						; WRITE
					SETB  	 	P3.3						; H-TO-L PULSE TO LATCH-IN
					CLR   		P3.3						; H-TO-L PULSE TO LATCH-IN
					RET										; RETURN TO THE CALLER PROGRAM

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_DLY:
					MOV   		R6,#3BH
HERE2:
					MOV   		R7,#0A8H
HERE1:
					DJNZ   		R7,HERE1	
					DJNZ   		R6,HERE2
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_SET:
; THIS SUBROUTINE SETS THE MODE OF OPERATION OF THE LCD
; IT CALLS LCD_CMD OSR TO LATCH-IN THE COMMAND
; OPERATING REGISTER: A
					MOV   	A, #38H							; 2 LINES, 5 X 7 MATRIX DISPLAY
					CALL   	LCD_CMD							; LATCH COMMAND JUST ABOVE INTO THE LCD
					MOV   	A, #0C0H						; DISPLAY ON SECOND LINE
					CALL   	LCD_CMD							; LATCH COMMAND JUST ABOVE INTO THE LCD
					MOV   	A, #06H							; INCREMENT FROM LEFT TO RIGHT
					CALL   	LCD_CMD							; LATCH COMMAND JUST ABOVE INTO THE LCD
 		         	MOV 	A, #0EH							; DISPLAY ON, CURSOR BLINKING
					CALL   	LCD_CMD							; LATCH COMMAND JUST ABOVE INTO THE LCD
  		        	MOV 	A, #01H							; CLEAR AND RETURN TO HOME
					CALL   	LCD_CMD							; LATCH COMMAND JUST ABOVE INTO THE LCD
					RET										; RETURN TO THE CALLER PROGRAM


; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_SHO:
; THIS SUBROUTINE SENDS THE ASCII CODE FOR THE DATA CHARATER TO BE DISPLAYED ON THE LCD
; IT CALLS READY (OSR) TO CHECK BUSY FLAG FOR DATA TO BE LATCHED-IN
; OPERATING REGISTER: A
; SFR BITS: P0 (LCD DATA PORT D0-D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
					ACALL 		GET_READY 					; IS LCD READY?
					MOV   		P0, A						; LATCH DATA INTO LCD DATA PORT	
					SETB   		P2.5						; RS=1, ACCESS LCD DATA REG
					CLR			P2.6						; R/!W=0, WRITE
					SETB   		P3.3						; H-TO-L PULSE TO LATCH-IN
					CLR   		P3.3						; H-TO-L PULSE TO LATCH-IN
					RET

; **********************************************
	       			ORG 		200H

LT_ROW_1: 			DB 			'0','1','2','3','4','5','6','7'		; DATA STORED IN ASCII CODE
LT_ROW_2: 			DB 			'E','R','T','U','I','O','P','8'
LT_ROW_3: 			DB 			'A','S','D','F','H','J','L','9'
LT_ROW_4: 			DB 			'Z','X','C','V','B','N','M','*'		; '*' IS RESERVED FOR THE FUNCTION 'NEXT'

					END