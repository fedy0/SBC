; THIS PROGRAM IS WRITTEN TO SATISFACTORILY GENERATE ALL THE INSTRUCTION SET (246) OF THE 8085 MICROPROCESSOR

; ================================================ MEMORY LOCATIONS ====================================================================
;					SMDC		EQU		30H					; SUB MEM DELAY COUNTER 4 X 500ms 
;					CDM			EQU		31H					; CHARACTER DISPLAY MEMORY (ACTS LIKE A TEMPORARY SAFE)
;					NC			EQU		32H					; NIBBLE COUNTER (THE NO. OF INTENDED NIBBLE TO BE OBTAINED IS LOADED IN IT)
;					BYTE1		EQU		33H					; 1ST BYTE CODE'S TEMPORARY LOCATION (FOR OPCODE ONLY)
;					BTYE2		EQU		34H					; 2ND BYTE CODE'S TEMPORARY LOCATION (FOR DATA OR LOWER ORDER BYTE OF AN ADDRESS)
;					BYTE3		EQU  	35H					; 3RD BYTE CODE'S TEMPORARY LOCATION (FOR THE HIGH ORDER BYTE OF AN ADDRESS)
;					H2AIM		EQU		36H					; HEX_2_ASCII INPUT MEMORY 
; 					CH2ALOB	   	EQU		37H					; CONVERTED HEX_2_ASCII LOW ORDER BYTE (CONTENT IS IN ASCII, READY FOR DISPLAY)
; 					CH2AHOB	   	EQU		38H					; CONVERTED HEX_2_ASCII HIGH ORDER BYTE (CONTENT IS IN ASCII, READY FOR DISPLAY)
;					NAHLOB		EQU		39H					; NEXT ADDRESS HOLDERS FOR LOB OR ADDRESS_DISPLAY_CONTROL'S INPUT MEM LOC 1 (THEY TEMPORARILY STORE THE CURRENT ADDRESS WHEN WRITING PROGRAM)
;					NAHHOB		EQU		3AH					; NEXT ADDRESS HOLDERS FOR HOB OR ADDRESS_DISPLAY_CONTROL'S INPUT MEM LOC 2
;					MHC			EQU		3BH					; M_HEX DIGIT COUNTER
;					VHADM1		EQU		3CH					; V_HEX ADDRESS DISPLAY MEMORY LOC. 1 FOR LOB
;					VHADM2		EQU		3DH					; V_HEX ADDRESS DISPLAY MEMORY LOC. 2 FOR HOB
;					SASML1		EQU		3EH					; START'S ADDRESS STORAGE MEM LOC. 1 FOR LOB (STORES THE BEGINNING ADDRESS)
;					SASML2		EQU		3FH					; START'S ADDRESS STORAGE MEM LOC. 2 FOR HOB (STORES THE BEGINNING ADDRESS)
;					EASML1		EQU		40H					; END'S ADDRESS STORAGE MEM LOC. 1 FOR LOB (STORES THE LAST/END ADDRESS)
;					EASML2		EQU		41H					; END'S ADDRESS STORAGE MEM LOC. 2 FOR HOB (STORES THE LAST/END ADDRESS)
; THE ADDRESS OF THE RESERVED AREAS CONTAINING THE RESULTS (OR CONTENT) OF THE EXAMINED REGISTERS ARE SAVED IN THE FOLLOWING MEMORY LOCATIONS
; 					PAM1		EQU		42H					; PAGE/SCREEN ADDRESS MEMORY LOCATION 1 FOR LOB(FOR CANCEL SR ONLY) = EXAMINED REGISTER A (LOB ADDRESS)
;					PAM2		EQU		43H					; PAGE/SCREEN ADDRESS MEMORY LOCATION 2 FOR HOB(FOR CANCEL SR ONLY)	= EXAMINED REGISTER A (HOB ADDRESS)
;					EXRB1		EQU		44H					; EXAMINED REGISTER B (LOB ADDRESS)
;					EXRB2		EQU		45H					; EXAMINED REGISTER B (HOB ADDRESS)
;					EXRC1		EQU		46H					; EXAMINED REGISTER C (LOB ADDRESS)
;					EXRC2		EQU		47H					; EXAMINED REGISTER C (HOB ADDRESS)
;					EXRD1		EQU		48H					; EXAMINED REGISTER D (LOB ADDRESS)
;					EXRD2		EQU		49H					; EXAMINED REGISTER D (HOB ADDRESS)
;					EXRE1		EQU		4AH					; EXAMINED REGISTER E (LOB ADDRESS)
;					EXRE2		EQU		4BH					; EXAMINED REGISTER E (HOB ADDRESS)
;					EXRH1		EQU		4CH					; EXAMINED REGISTER H (LOB ADDRESS)
;					EXRH2		EQU		4DH					; EXAMINED REGISTER H (HOB ADDRESS)
;					EXRL1		EQU		4EH					; EXAMINED REGISTER L (LOB ADDRESS)
;					EXRL2		EQU		4FH					; EXAMINED REGISTER L (HOB ADDRESS)
;					DML1		EQU		50H					; DELAY'S MEM LOCATION 1
;					DML2		EQU		51H					; DELAY'S MEM LOCATION 2
;					DML3		EQU		52H					; DELAY'S MEM LOCATION 3

; ================================================= FLAG LOCATIONS =====================================================================
; 					SMF			BIT		00H					; SUB MEM FLAG
;					KPF			BIT		01H					; KEY PRESSED FLAG
;					HNF			BIT		02H					; HEX NIBBLE FLAG
;					NTF			BIT		03H					; NEXT TYPE FLAG (OPCODE TYPE 03H= 0, OPERAND TYPE 03H= 1)
;					BIF			BIT		04H					; BYTE INDICATOR FLAG (INDICATES WHEN AN OPERAND IS A 2 BYTE(4 NIBBLES) OR 1 BYTE (2NIBBLES) )
;					NMCF		BIT		05H					; NIBBLE MARRIAGE CONTROL FLAG
;					MCF			BIT		06H					; MARRIAGE COMPLETION FLAG ONLY FOR HIGH ORDER BYTE (MCF=1 ON MARRIAGE COMPLETION)
;					NOTF		BIT		07H					; NEXT OPERAND TYPE FLAG (DATA TYPE OPERAND 07H = 0, ADDRESS TYPE OPERAND 07H = 1)
; 					NSF			BIT		08H					; NEXT SUB MEM FLAG (SELECTS THE PART OF THE NEXT SR MEANT FOR SUB MEM)
;					CPLTF		BIT		09H					; CODE/PROGRAMMING LANGUAGE TYPE FLAG
;					MHF			BIT		0AH					; M_HEX FLAG FOR SWAP SELECTION (HELPS TO FORMAT DATA IN MHEX SR)		
;					VHDF		BIT		0BH					; V_HEX DECREMENT FLAG
;					EF			BIT		0CH					; END'S FLAG

; ==================================================== MACROS ==========================================================================
CLR_LCD    			MACRO									; CLEAR LCD
        			MOV     	A, #01H
       				LCALL   	LCD_CMD																			
           			ENDM  
; --------------------------------------------------------------------------------------------------------------------------------------
D_STR     			MACRO									; DISPLAY STRINGS OF CHARACTER
       				LCALL    	LCD_CMD
        			LCALL    	DISP_CHAR
           			ENDM
; ========================================================  MAIN  ======================================================================
					ORG			0000H
					JMP			MAIN						; ON SYSTEM RESET, JUMP TO MAIN
					
					ORG			0003H
					JMP			SECOND_FUNCTION				; ON SYSTEM EXTERNAL INTERRUPT 0, JUMP TO THE ISR 'SECOND_FUNCTION'

					ORG			0030H
MAIN:														; THE MAIN PROGRAM BEGINS HERE
					MOV			SP, #57H					; INITIALIZATION OF THE TOP OF THE STACK(40 BYTES OF MEM. ARE AVAILABLE ON THIS INITIALIZATION)
					LCALL 		LCD_SET						; SET THE LCD FOR PROPER PERFORMANCE
					LCALL		INTRO_MSG					; CALLS AN OSR TO DISPLAY LINE 1: '   SBC 8085uP   '
															;                         LINE 2: 'by IFEDIORA E.C.'  OR 'by FEDYRONIX INC'
MAIN1:				CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED TO CONTINUE
					JNB			01H, MAIN1
					CLR			01H							; GET READY FOR NEXT KEY
															
					CLR_LCD									; CLEAR THE LCD (NOTE THIS RESET THE ADDRESS OF THE DDRAM TO 80H
					LCALL		INTRO_CPLT					; CALLS AN OSR TO DISPLAY LINE 1: 'Press 0 for MHEX'
															;                         LINE 2: 'Press 1 for ASM' 
MAIN1_1:			CALL		KEYPAD_ID					; ENSURE THAT EITHER '0' OR '1' KEY IS DEPRESSED
					JNB			01H, MAIN1_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'0', MAIN1_2
					CLR			09H							; SELECTS MHEX
					MOV			3BH, #02H					; MOVE '2' INTO THE MHEX COUNTER
					SJMP		MAIN1_3
MAIN1_2:			CJNE		A, #'1', MAIN1_1
					SETB		09H							; SELECTS ASM

MAIN1_3:			MOV 		IE, #10000001B				; ENABLE THE !INT0 EXTERNAL INTERRUPT (SECOND_FUNCTION ISR)

					CLR_LCD
					LCALL		INTRO_SUBMEM_REQUEST		; CALLS AN OSR TO DISPLAY ON LINE 1: 'Enter start addr'

					MOV			30H,#04H					; LOAD '4' INTO THE COUNTER 
					JNB			00H, $						; STAY HERE TILL THE SUB MEM IS PRESSED


MAIN2:				MOV			A, #0C0H					; INSTRUCTION/COMMAND TO CARRY OUT DISPLAY ON LINE 2
					CALL		LCD_CMD

					JNB			09H, M_HEX					; USE MACHINE LANGUAGE FOR 09H = 0 ELSE USE ASM FOR 09H = 1


; =*=*=*=*=*=*=*=*=*=*=*=*=*        ASSEMBLY LANGUAGE AS THE CODE/PROGRAMMING LANGUAGE TYPE (CPLT)        =*=*=*=*=*=*=*=*=*=*=*=*=*=
; ------------------------------------------ FIRST LETTER KEY COMBINATION -----------------------------------------------------------


ASM:				CALL		KEYPAD_ID					; ENSURE A KEY (1ST KEY) IS DEPRESSED
					JNB			01H, ASM
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', ASM1_1				; JUMP TO A'S SECOND CHARACTER ELSE CONTINUE
					JMP			A2
ASM1_1:				CJNE		A, #'C', ASM1_2				; JUMP TO C'S SECOND CHARACTER ELSE CONTINUE 
					JMP			C2
ASM1_2:				CJNE		A, #'D', ASM1_3				; JUMP TO D'S SECOND CHARACTER ELSE CONTINUE 
					JMP			D2
ASM1_3:				CJNE		A, #'E', ASM1_4				; EVALUATE E (ie EI) ELSE CONTINUE
					CALL		LCD_SHO
					MOV			A, #'I'
					MOV			33H, #0FBH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; EXPORT THE OPCODE
					SJMP		MAIN2

ASM1_4:				CJNE		A, #'H', ASM1_5				; EVALUATE H (ie HLT) ELSE CONTINUE
					CALL		LCD_SHO
					MOV			A, #'L'
					CALL		LCD_SHO
					MOV			A, #'T'
					MOV			33H, #76H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; EXPORT THE OPCODE
					SJMP		MAIN2

ASM1_5:				CJNE		A, #'I', ASM1_6				; JUMP TO I'S SECOND CHARACTER ELSE CONTINUE 
					JMP			I2
ASM1_6:				CJNE		A, #'J', ASM1_7				; JUMP TO J'S SECOND CHARACTER ELSE CONTINUE 
					JMP			J2
ASM1_7:				CJNE		A, #'L', ASM1_8				; JUMP TO L'S SECOND CHARACTER ELSE CONTINUE 
					JMP			L2
ASM1_8:				CJNE		A, #'M', ASM1_9				; JUMP TO M'S SECOND CHARACTER ELSE CONTINUE 
					JMP			M2

ASM1_9:				CJNE		A, #'N', ASM1_10			; EVALUATE N (ie NOP) ELSE CONTINUE
					CALL		LCD_SHO
					MOV			A, #'O'
					CALL		LCD_SHO
					MOV			A, #'P'
					MOV			33H, #00H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; EXPORT THE OPCODE
					SJMP		MAIN2

ASM1_10:			CJNE		A, #'O', ASM1_11			; JUMP TO O'S SECOND CHARACTER ELSE CONTINUE 
					JMP			O2
ASM1_11:			CJNE		A, #'P', ASM1_12			; JUMP TO P'S SECOND CHARACTER ELSE CONTINUE 
					JMP			_P2
ASM1_12:			CJNE		A, #'R', ASM1_13			; JUMP TO R'S SECOND CHARACTER ELSE CONTINUE 
					JMP			_R2
ASM1_13:			CJNE		A, #'S', ASM1_14			; JUMP TO S'S SECOND CHARACTER ELSE CONTINUE 
					JMP			S2
ASM1_14:			CJNE		A, #'X', ASM				; JUMP TO X'S SECOND CHARACTER ELSE START AFRESH 
					JMP			X2

; ------------------------------------------ SECOND, THIRD & FOURTH CHARACTER KEY COMBINATION -----------------------------------------------------------

; FOR 'A' AS FIRST CHARACTER
A2:					CALL 		LCD_SHO
A2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, A2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', A2_2				; ACI
					CALL 		LCD_SHO
					MOV			A, #'I'
					MOV			33H, #0CEH					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

A2_2:				CJNE		A, #'D', A2_3				; CHECK MATCH FOR AD'S THIRD CHARACTER ELSE CONTINUE 
					CALL 		LCD_SHO
A2_2L1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, A2_2L1
					CLR			01H							; GET READY FOR NEXT KEY
				
					CJNE		A, #'C', A2_2L2				; ADC
					JMP			ADC_						; JUMP TO ADC OPERAND ELSE CONTINUE
A2_2L2:				CJNE		A, #'D', A2_2L3				; ADD
					JMP			ADD_						; JUMP TO ADD OPERAND ELSE CONTINUE
A2_2L3:				CJNE		A, #'I', A2_2L1				; ADI
					MOV			33H, #0C6H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

A2_3:				CJNE		A, #'N', A2_1				; CHECK MATCH FOR AN'S THIRD CHARACTER ELSE CONTINUE 
					CALL 		LCD_SHO
A2_3L1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, A2_3L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', A2_3L2				; ANA
					JMP			ANA_						; JUMP TO ANA OPERAND ELSE CONTINUE
A2_3L2:				CJNE		A, #'I', A2_3L1				; ANI 
					MOV			33H, #0E6H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

; FOR 'C' AS FIRST CHARACTER
C2:					CALL 		LCD_SHO
C2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, C2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', C2_2				; CALL
					D_STR
					DB			'ALL',0
					MOV			33H, #0CDH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

C2_2:				CJNE		A, #'C', C2_3				; CC 
					MOV			33H, #0DCH
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

C2_3:				CJNE		A, #'M', C2_4				; CM'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
C2_3L1:				CALL		KEYPAD_ID
					JNB			01H, C2_3L1					; GET READY FOR NEXT KEY
					CLR			01H

					CJNE		A, #'*', C2_3L2				; CM
					MOV			33H, #0FCH
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
C2_3L2:				CJNE		A, #'A', C2_3L3				; CMA
					MOV			33H, #2FH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

C2_3L3:				CJNE		A, #'C', C2_3L4				; CMC
					MOV			33H, #3FH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD OPCODE IN-TAKE
					AJMP		MAIN2

C2_3L4:				CJNE		A, #'P', C2_3L1
					JMP			CMP_						; JUMP TO CMP'S OPERAND CHARACTER ELSE CONTINUE 
; -------
C2_4:				CJNE		A, #'N', C2_5				; JUMP TO CN'S THIRD CHARACTER ELSE CONTINUE 
					CALL 		LCD_SHO
C2_4L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, C2_4L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', C2_4L2				; CNC
					MOV			33H, #0D4H
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
C2_4L2:				CJNE		A, #'Z', C2_4L1				; CNZ
					MOV			33H, #0C4H
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

C2_5:				CJNE		A, #'P', C2_6				; JUMP TO CP'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
C2_5L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, C2_5L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', C2_5L2				; CP
					MOV			33H, #0F4H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
C2_5L2:				CJNE		A, #'E', C2_5L3				; CPE
					MOV			33H, #0ECH
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

C2_5L3:				CJNE		A, #'I', C2_5L4				; CPI
					MOV			33H, #0FEH					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

C2_5L4:				CJNE		A, #'O', C2_5L1				; CPO
					MOV			33H, #0E4H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2


C2_6:				CJNE		A, #'Z', C2_7				; JUMP TO AN'S THIRD CHARACTER ELSE CONTINUE 
					MOV			33H, #0CCH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
C2_7:				AJMP		C2_1						; I PLACE THIS INSTRUCTION HERE DUE OUT OF RANGE ERROR

; FOR 'D' AS FIRST CHARACTER
D2:					CALL 		LCD_SHO
D2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, D2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', D2_2				; JUMP TO DA'S THIRD CHARACTER ELSE CONTINUE
					CALL		LCD_SHO
D2_1L1:				CALL 		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, D2_1L1					; GET READY FOR NEXT KEY
					CLR			01H

					CJNE		A, #'A', D2_1L2				; DAA
					MOV			33H, #27H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
D2_1L2:				CJNE		A, #'D', D2_1L1				; DAD
					JMP			DAD_						; JUMP TO DAD'S OPERAND CHARACTER ELSE CONTINUE 

D2_2:				CJNE		A, #'C', D2_3				; JUMP TO DC'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
D2_2L1:				CALL 		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, D2_2L1					; GET READY FOR NEXT KEY
					CLR			01H		
					
					CJNE		A, #'R', D2_2L2				; DCR
					JMP			DCR_						; JUMP TO DCR'S OPERAND CHARACTER ELSE CONTINUE 
D2_2L2:				CJNE		A, #'X', D2_2L1				; DCX
					JMP			DCX_						; JUMP TO DCX'S OPERAND CHARACTER ELSE CONTINUE 
													
D2_3:				CJNE		A, #'I', D2_1				; JUMP TO AN'S THIRD CHARACTER ELSE CONTINUE 
					MOV			33H, #0F3H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

; FOR 'I' AS FIRST CHARACTER
I2:					CALL 		LCD_SHO
					MOV			A, #'N'					    ; SHOW 'IN' AT ONCE AND WAIT FOR 'NEXT SR', CHARACTER 'R' OR 'X'
					CALL		LCD_SHO
I2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, I2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', I2_2				; IN
					MOV			33H, #0DBH					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2		
I2_2:				CJNE		A, #'R', I2_3
					JMP			INR_						; JUMP TO INR'S OPERAND CHARACTER ELSE CONTINUE 
I2_3:				CJNE		A, #'X', I2_1
					JMP			INX_						; JUMP TO INX'S OPERAND CHARACTER ELSE CONTINUE 

; FOR 'J' AS FIRST CHARACTER
J2:					CALL 		LCD_SHO
J2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, J2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', J2_2				; JC
					MOV			33H, #0DAH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

J2_2:				CJNE		A, #'M', J2_3				; JM'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
J2_2L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, J2_2L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', J2_2L2				; JM
					MOV			33H, #0FAH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2		
J2_2L2:				CJNE		A, #'P', J2_2L1				; JMP
					MOV			33H, #0C3H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2				

J2_3:				CJNE		A, #'N', J2_4				; JN'S THIRD CHARACTER ELSE CONTINUE 
					CALL 		LCD_SHO
J2_3L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, J2_3L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', J2_3L2				; JNC
					MOV			33H, #0D2H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
J2_3L2:				CJNE		A, #'Z', J2_3L1				; JNZ
					MOV			33H, #0C2H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2	 

J2_4:				CJNE		A, #'P', J2_5				; JP'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
J2_4L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, J2_4L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', J2_4L2				; JP
					MOV			33H, #0F2H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2		
J2_4L2:				CJNE		A, #'E', J2_4L3				; JPE
					MOV			33H, #0EAH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
J2_4L3:				CJNE		A, #'O', J2_4L1				; JPO
					MOV			33H, #0E2H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

J2_5:				CJNE		A, #'Z', J2_6				; JZ 
					MOV			33H, #0CAH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
J2_6:				AJMP		J2_1						; I PLACE THIS INSTRUCTION HERE DUE OUT OF RANGE ERROR

; FOR 'L' AS FIRST CHARACTER
L2:					CALL 		LCD_SHO
L2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, L2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'D', L2_2				; JUMP TO LDA'S FOURTH CHARACTER ELSE CONTINUE
					CALL		LCD_SHO
					MOV			A, #'A'						
					CALL		LCD_SHO
L2_1L1:				CALL		KEYPAD_ID					; ENSURE A KEY(4TH ALPHABET KEY) IS DEPRESSED
					JNB			01H, L2_1L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', L2_1L2				; LDA
					MOV			33H, #3AH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2		
L2_1L2:				CJNE		A, #'X', L2_1L1				; LDAX
					JMP			LDAX_						; JUMP TO LDAX'S OPERANDS ELSE CONTINUE

L2_2:				CJNE		A, #'H', L2_3				; LHLD 
					D_STR
					DB			'HLD',0
					MOV			33H, #2AH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

L2_3:				CJNE		A, #'X', L2_1				; JUMP TO AN'S THIRD CHARACTER ELSE CONTINUE 
					CALL 		LCD_SHO
					MOV			A, #'I'
					JMP			LXI_						; JUMP TO LXI'S OPERANDS ELSE CONTINUE  

; FOR 'M' AS FIRST CHARACTER
M2:					CALL 		LCD_SHO
M2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, M2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'O', M2_2				; MOV
					CALL 		LCD_SHO
					MOV			A, #'V'
					JMP			MOV_						; JUMP TO MOV'S OPERAND CHARACTERS ELSE CONTINUE

M2_2:				CJNE		A, #'V', M2_1				; MVI
					CALL 		LCD_SHO
					MOV			A, #'I'
					JMP			MVI_						; JUMP TO MOV'S OPERAND CHARACTERS ELSE CONTINUE

; FOR 'O' AS FIRST CHARACTER
O2:					CALL 		LCD_SHO
O2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, O2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'R', O2_2				; JUMP TO OR'S THIRD CHARACTERS ELSE CONTINUE
					CALL 		LCD_SHO
O2_1L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, O2_1L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', O2_1L2				; ORA
					JMP			ORA_						; JUMP TO ORA'S OPERAND CHARACTERS ELSE CONTINUE
O2_1L2:				CJNE		A, #'I', O2_1L1				; ORI
					MOV			33H, #0F6H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

O2_2:				CJNE		A, #'U', O2_1				; OUT 
					CALL		LCD_SHO
					MOV			A, #'T'
					MOV			33H, #0D3H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

; FOR 'P' AS FIRST CHARACTER
_P2:				CALL 		LCD_SHO
_P2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, _P2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', _P2_2				; PCHL
					D_STR
					DB			'CHL',0
					MOV			33H, #0E9H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2
_P2_2:				CJNE		A, #'O', _P2_3				; POP
					CALL		LCD_SHO
					MOV			A, #'P'
					JMP			POP_						; JUMP TO POP'S OPERAND CHARACTERS ELSE CONTINUE 
_P2_3:				CJNE		A, #'U', _P2_1				; PUSH
					D_STR
					DB			'USH',0
					JMP			PUSH_						; JUMP TO PUSH'S OPERAND CHARACTERS ELSE CONTINUE 

; FOR 'R' AS FIRST CHARACTER
_R2:				CALL 		LCD_SHO
_R2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, _R2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', _R2_2				; JUMP TO RA'S THIRD CHARACTERS ELSE CONTINUE
					CALL		LCD_SHO
_R2_1L1:			CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, _R2_1L1
					CLR			01H		

					CJNE		A, #'L', _R2_1L2			; RAL
					MOV			33H, #17H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
_R2_1L2:			CJNE		A, #'R', _R2_1L1			; RAR
					MOV			33H, #1FH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_2:				CJNE		A, #'C', _R2_3				; RC 
					MOV			33H, #0D8H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_3:				CJNE		A, #'E', _R2_4				; RET 
					CALL		LCD_SHO
					MOV			A, #'T'
					MOV			33H, #0C9H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_4:				CJNE		A, #'I', _R2_5				; RIM
					CALL		LCD_SHO
					MOV			A, #'M'
					MOV			33H, #20H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_5:				CJNE		A, #'L', _R2_6				; RLC 
					CALL		LCD_SHO
					MOV			A, #'C'
					MOV			33H, #07H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_6:				CJNE		A, #'M', _R2_7				; RM 
					MOV			33H, #0F8H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_7:				CJNE		A, #'N', _R2_8				; JUMP TO RN'S THIRD CHARATER ELSE CONTINUE
					CALL		LCD_SHO
_R2_7L1:			CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, _R2_7L1
					CLR			01H		

					CJNE		A, #'C', _R2_7L2			; RNC
					MOV			33H, #0D0H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
_R2_7L2:			CJNE		A, #'Z', _R2_7L1			; RNZ
					MOV			33H, #0C0H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_8:				CJNE		A, #'P', _R2_9				; JUMP TO RP'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
_R2_8L1:			CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, _R2_8L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', _R2_8L2			; RP
					MOV			33H, #0F0H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2		

_R2_8L2:			CJNE		A, #'E', _R2_8L3			; RPE
					MOV			33H, #0E8H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
 					AJMP		MAIN2

_R2_8L3:			CJNE		A, #'O', _R2_8L1			; RPO
					MOV			33H, #0E0H				    ; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
 					AJMP		MAIN2
; -------
_R2_9:				CJNE		A, #'R', _R2_10				; RRC 
					CALL		LCD_SHO
					MOV			A, #'C'
					MOV			33H, #0FH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_10:				CJNE		A, #'S', _R2_11				; RST
					CALL		LCD_SHO
					MOV			A, #'T'
					CALL		LCD_SHO						
					MOV			A, #' '
					CALL		LCD_SHO						; GET RST'S 4TH CHARACTER

_R2_10L1:			CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, _R2_10L1				
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'0', _R2_10L2			; RST 0
					MOV			33H, #0C7H					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L2:			CJNE		A, #'1', _R2_10L3			; RST 1
					MOV			33H, #0CFH					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L3:			CJNE		A, #'2', _R2_10L4			; RST 2
					MOV			33H, #0D7H					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L4:			CJNE		A, #'3', _R2_10L5			; RST 3
					MOV			33H, #0DFH					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L5:			CJNE		A, #'4', _R2_10L6			; RST 4
					MOV			33H, #0E7H					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L6:			CJNE		A, #'5', _R2_10L7			; RST 5
					MOV			33H, #0EFH					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L7:			CJNE		A, #'6', _R2_10L8			; RST 6
					MOV			33H, #0F7H					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L8:			CJNE		A, #'7', _R2_10L1			; RST 7
					MOV			33H, #0FFH					; LOAD ITS 8085 INST. SET
_R2_10L9:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_11:				CJNE		A, #'Z', _R2_12				; JUMP TO AD'S THIRD CHARACTER ELSE CONTINUE 
					MOV			33H, #0C8H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
_R2_12:				AJMP		_R2_1						; I PLACED THIS INSTRUCTION DUE TO OUT OF RANGE ERROR

; FOR 'S' AS FIRST CHARACTER
S2:					CALL 		LCD_SHO
S2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, S2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'B', S2_2				; JUMP TO SB'S THIRD CHARACTER
					CALL		LCD_SHO
S2_1L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED 
					JNB			01H, S2_1L1
					CLR			01H							; GET READY FOR NEXT KEY
					CJNE		A, #'B', S2_1L2				; SBB
					JMP			SBB_						; JUMP TO SBB OPERAND CHARACTERS
S2_1L2:				CJNE		A, #'I', S2_1L1				; SBI					
					MOV			33H, #0DEH					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

S2_2:				CJNE		A, #'H', S2_3				; SHLD 
					D_STR
					DB			'HLD',0
					MOV			33H, #22H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
S2_3:				CJNE		A, #'I', S2_4				; SIM 
					CALL		LCD_SHO
					MOV			A, #'M'
					MOV			33H, #30H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

S2_4:				CJNE		A, #'P', S2_5				; SPHL
					D_STR
					DB			'PHL',0
					MOV			33H, #0F9H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

S2_5:				CJNE		A, #'T', S2_6				; JUMP TO ST'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
					
S2_5L1:				CALL		KEYPAD_ID
					JNB			01H, S2_5L1
					CLR			01H	
					CJNE		A, #'A', S2_5L2				; GET STA'S FOURTH CHARACTER
					CALL		LCD_SHO						
S2_5L1L1:			CALL		KEYPAD_ID					
					JNB			01H, S2_5L1L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'*', S2_5L1L2			; STA
					MOV			33H, #32H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2		
S2_5L1L2:			CJNE		A, #'X', S2_5L1L1			; STAX
					JMP			STAX_						; JUMP TO STAX'S OPERAND CHARACTERS

S2_5L2:				CJNE		A, #'C', S2_5L1				; STC
					MOV			33H, #37H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

S2_6:				CJNE		A, #'U', S2_7				; JUMP TO SU'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
S2_6L1:				CALL		KEYPAD_ID					; ENSURE THAT A KEY IS PREESSED
					JNB			01H, S2_6L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', S2_6L2				; SUB
					JMP			SUB_						; JUMP TO SUB'S OPERAND CHARACTERS
S2_6L2:				CJNE		A, #'I', S2_6L1				; SUI					
					MOV			33H, #0D6H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2
S2_7:				AJMP		S2_1						; I PLACED THIS INSTRUCTION DUE TO OUT OF RANGE ERROR

; FOR 'X' AS FIRST CHARACTER
X2:					CALL 		LCD_SHO
X2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, X2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', X2_2				; XCHG ELSE CONTINUE
					D_STR
					DB			'CHG',0
					MOV			33H, #0EBH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

X2_2:				CJNE		A, #'R', X2_3				; JUMP TO AD'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
X2_2L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, X2_2L1
					CLR			01H							; GET READY FOR NEXT KEY
					
					CJNE		A, #'A', X2_2L2				; XRA
					JMP			XRA							; JUMP TO XRA'S OPERAND CHARACTERS
X2_2L2:				CJNE		A, #'I', X2_2L1				; XRI
					MOV			33H, #0EEH					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

X2_3:				CJNE		A, #'T', X2_1				; XTHL ELSE CONTINUE 
					D_STR
					DB			'THL',0
					MOV			33H, #0E3H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

; ------------------------------------------ OPERAND CHARACTER KEY COMBINATION -----------------------------------------------------------

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'ADC...'
ADC_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE 
					CALL		LCD_SHO
ADC_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, ADC_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', ADC_L2				; ADC A
					MOV			33H, #8FH					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L2:				CJNE		A, #'B', ADC_L3				; ADC B
					MOV			33H, #88H					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L3:				CJNE		A, #'C', ADC_L4				; ADC C
					MOV			33H, #89H					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L4:				CJNE		A, #'D', ADC_L5				; ADC D
					MOV			33H, #8AH					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L5:				CJNE		A, #'E', ADC_L6				; ADC E
					MOV			33H, #8BH					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L6:				CJNE		A, #'H', ADC_L7				; ADC H
					MOV			33H, #8CH					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L7:				CJNE		A, #'L', ADC_L8				; ADC L
					MOV			33H, #8DH					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L8:				CJNE		A, #'M', ADC_L1				; ADC M
					MOV			33H, #8EH					; LOAD ITS 8085 INST. SET

ADC_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

; ***** FOR 'ADD...'
ADD_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
ADD_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, ADD_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', ADD_L2				; ADD A
					MOV			33H, #87H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L2:				CJNE		A, #'B', ADD_L3				; ADD B
					MOV			33H, #80H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9	   
ADD_L3:				CJNE		A, #'C', ADD_L4				; ADD C
					MOV			33H, #81H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L4:				CJNE		A, #'D', ADD_L5				; ADD D
					MOV			33H, #82H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L5:				CJNE		A, #'E', ADD_L6				; ADD E
					MOV			33H, #83H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L6:				CJNE		A, #'H', ADD_L7				; ADD H
					MOV			33H, #84H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L7:				CJNE		A, #'L', ADD_L8				; ADD L
					MOV			33H, #85H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L8:				CJNE		A, #'M', ADD_L1				; ADD M
					MOV			33H, #86H					; LOAD ITS 8085 INST. SET

ADD_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

; ***** FOR 'ANA...'
ANA_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
ANA_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, ANA_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', ANA_L2				; ANA A
					MOV			33H, #0A7H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L2:				CJNE		A, #'B', ANA_L3				; ANA B
					MOV			33H, #0A0H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L3:				CJNE		A, #'C', ANA_L4				; ANA C
					MOV			33H, #0A1H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L4:				CJNE		A, #'D', ANA_L5				; ANA D
					MOV			33H, #0A2H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L5:				CJNE		A, #'E', ANA_L6				; ANA E
					MOV			33H, #0A3H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L6:				CJNE		A, #'H', ANA_L7				; ANA H
					MOV			33H, #0A4H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L7:				CJNE		A, #'L', ANA_L8				; ANA L
					MOV			33H, #0A5H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L8:				CJNE		A, #'M', ANA_L1				; ANA M
					MOV			33H, #0A6H					; LOAD ITS 8085 INST. SET

ANA_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'CMP...'
CMP_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
CMP_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, CMP_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', CMP_L2				; CMP A
					MOV			33H, #0BFH					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L2:				CJNE		A, #'B', CMP_L3				; CMP B
					MOV			33H, #0B8H					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L3:				CJNE		A, #'C', CMP_L4				; CMP C
					MOV			33H, #0B9H					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L4:				CJNE		A, #'D', CMP_L5				; CMP D
					MOV			33H, #0BAH					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L5:				CJNE		A, #'E', CMP_L6				; CMP E
					MOV			33H, #0BBH					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L6:				CJNE		A, #'H', CMP_L7				; CMP H
					MOV			33H, #0BCH					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L7:				CJNE		A, #'L', CMP_L8				; CMP L
					MOV			33H, #0BDH					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L8:				CJNE		A, #'M', CMP_L1				; CMP M
					MOV			33H, #0BEH					; LOAD ITS 8085 INST. SET

CMP_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'DAD...'
DAD_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
DAD_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, DAD_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', DAD_L2				; DAD B
					MOV			33H, #09H					; LOAD ITS 8085 INST. SET
					SJMP		DAD_L5
DAD_L2:				CJNE		A, #'D', DAD_L3				; DAD D
					MOV			33H, #19H					; LOAD ITS 8085 INST. SET
					SJMP		DAD_L5
DAD_L3:				CJNE		A, #'H', DAD_L4				; DAD H
					MOV			33H, #29H					; LOAD ITS 8085 INST. SET
					SJMP		DAD_L5
DAD_L4:				CJNE		A, #'S', DAD_L1				; DAD SP
					CALL		LCD_SHO
					MOV			A, #'P'
					MOV			33H, #39H					; LOAD ITS 8085 INST. SET

DAD_L5:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

; ***** FOR 'DCR...'
DCR_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
DCR_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, DCR_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', DCR_L2				; DCR A
					MOV			33H, #3DH					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L2:				CJNE		A, #'B', DCR_L3				; DCR B
					MOV			33H, #05H					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L3:				CJNE		A, #'C', DCR_L4				; DCR C
					MOV			33H, #0DH					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L4:				CJNE		A, #'D', DCR_L5				; DCR D
					MOV			33H, #15H					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L5:				CJNE		A, #'E', DCR_L6				; DCR E
					MOV			33H, #1DH					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L6:				CJNE		A, #'H', DCR_L7				; DCR H
					MOV			33H, #25H					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L7:				CJNE		A, #'L', DCR_L8				; DCR L
					MOV			33H, #2DH					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L8:				CJNE		A, #'M', DCR_L1				; DCR M
					MOV			33H, #35H					; LOAD ITS 8085 INST. SET

DCR_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

; ***** FOR 'DCX...'
DCX_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
DCX_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, DCX_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', DCX_L2				; DCX B
					MOV			33H, #0BH					; LOAD ITS 8085 INST. SET
					SJMP		DCX_L5
DCX_L2:				CJNE		A, #'D', DCX_L3				; DCX D
					MOV			33H, #1BH					; LOAD ITS 8085 INST. SET
					SJMP		DCX_L5
DCX_L3:				CJNE		A, #'H', DCX_L4				; DCX H
					MOV			33H, #2BH					; LOAD ITS 8085 INST. SET
					SJMP		DCX_L5
DCX_L4:				CJNE		A, #'S', DCX_L1				; DCX SP
					CALL		LCD_SHO
					MOV			A, #'P'
					MOV			33H, #3BH					; LOAD ITS 8085 INST. SET

DCX_L5:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'INR...'
INR_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
INR_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, INR_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', INR_L2				; INR A
					MOV			33H, #3CH					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L2:				CJNE		A, #'B', INR_L3				; INR B
					MOV			33H, #04H					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L3:				CJNE		A, #'C', INR_L4				; INR C
					MOV			33H, #0CH					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L4:				CJNE		A, #'D', INR_L5				; INR D
					MOV			33H, #14H					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L5:				CJNE		A, #'E', INR_L6				; INR E
					MOV			33H, #1CH				 	; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L6:				CJNE		A, #'H', INR_L7				; INR H
					MOV			33H, #24H					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L7:				CJNE		A, #'L', INR_L8				; INR L
					MOV			33H, #2CH					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L8:				CJNE		A, #'M', INR_L1				; INR M
					MOV			33H, #34H					; LOAD ITS 8085 INST. SET

INR_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ***** FOR 'INX...'
INX_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
INX_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, INX_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', INX_L2				; INX B
					MOV			33H, #03H					; LOAD ITS 8085 INST. SET
					SJMP		INX_L5
INX_L2:				CJNE		A, #'D', INX_L3				; INX D
					MOV			33H, #13H					; LOAD ITS 8085 INST. SET
					SJMP		INX_L5
INX_L3:				CJNE		A, #'H', INX_L4				; INX H
					MOV			33H, #23H					; LOAD ITS 8085 INST. SET
					SJMP		INX_L5
INX_L4:				CJNE		A, #'S', INX_L1				; INX SP
					CALL		LCD_SHO
					MOV			A, #'P'
					MOV			33H, #33H					; LOAD ITS 8085 INST. SET

INX_L5:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'LDAX...'
LDAX_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
LDAX_L1:			CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, LDAX_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', LDAX_L2			; LDAX B
					MOV			33H, #0AH					; LOAD ITS 8085 INST. SET
					SJMP		LDAX_L3
LDAX_L2:			CJNE		A, #'D', LDAX_L1			; LDAX D
					MOV			33H, #1AH					; LOAD ITS 8085 INST. SET

LDAX_L3:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ***** FOR 'LXI...'
LXI_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
LXI_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, LXI_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', LXI_L2				; LXI B
					MOV			33H, #01H					; LOAD ITS 8085 INST. SET
					SJMP		LXI_L5
LXI_L2:				CJNE		A, #'D', LXI_L3				; LXI D
					MOV			33H, #11H					; LOAD ITS 8085 INST. SET
					SJMP		LXI_L5
LXI_L3:				CJNE		A, #'H', LXI_L4				; LXI H
					MOV			33H, #21H					; LOAD ITS 8085 INST. SET
					SJMP		LXI_L5
LXI_L4:				CJNE		A, #'S', LXI_L1				; LXI SP
					CALL		LCD_SHO						; LOAD ITS 8085 INST. SET
					MOV			A, #'P'
					MOV			33H, #31H					; LOAD ITS 8085 INST. SET

LXI_L5:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'MOV...'
MOV_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO

				; -- A -- ;
MOV_A:				CALL		KEYPAD_ID					; GET THE FIRST OPERAND 
					JNB			01H, MOV_A
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', MOV_B
					D_STR
					DB			'A, ',0						; MOV A,
															
MOV_AA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_AA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_AB				; MOV A, A
					MOV			33H, #7FH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT
MOV_AB:				CJNE		A, #'B', MOV_AC				; MOV A, B 
					MOV			33H, #78H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AC:				CJNE		A, #'C', MOV_AD				; MOV A, C
					MOV			33H, #79H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AD:				CJNE		A, #'D', MOV_AE				; MOV A, D
					MOV			33H, #7AH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AE:				CJNE		A, #'E', MOV_AH				; MOV A, E
					MOV			33H, #7BH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AH:				CJNE		A, #'H', MOV_AL				; MOV A, H
					MOV			33H, #7CH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AL:				CJNE		A, #'L', MOV_AM				; MOV A, L
					MOV			33H, #7DH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AM:				CJNE		A, #'M', MOV_AA				; MOV A, M
					MOV			33H, #7EH					; LOAD ITS 8085 INST. SET

MOV_A_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- B -- ;
MOV_B:				CJNE		A, #'B', MOV_C
					D_STR
					DB			'B, ',0						; MOV B,

MOV_BA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_BA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_BB				; MOV B, A
					MOV			33H, #47H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT
MOV_BB:				CJNE		A, #'B', MOV_BC				; MOV B, B
					MOV			33H, #40H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BC:				CJNE		A, #'C', MOV_BD				; MOV B, C
					MOV			33H, #41H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BD:				CJNE		A, #'D', MOV_BE				; MOV B, D
					MOV			33H, #42H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BE:				CJNE		A, #'E', MOV_BH				; MOV B, E
					MOV			33H, #43H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BH:				CJNE		A, #'H', MOV_BL				; MOV B, H
					MOV			33H, #44H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BL:				CJNE		A, #'L', MOV_BM				; MOV B, L
					MOV			33H, #45H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BM:				CJNE		A, #'M', MOV_BA				; MOV B, M
					MOV			33H, #46H					; LOAD ITS 8085 INST. SET

MOV_B_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- C -- ;
MOV_C:				CJNE		A, #'C', MOV_D
					D_STR
					DB			'C, ',0						; MOV C,

MOV_CA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_CA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_CB				; MOV C, A
					MOV			33H, #4FH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT
MOV_CB:				CJNE		A, #'B', MOV_CC				; MOV C, B
					MOV			33H, #48H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CC:				CJNE		A, #'C', MOV_CD				; MOV C, C
					MOV			33H, #49H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CD:				CJNE		A, #'D', MOV_CE				; MOV C, D
					MOV			33H, #4AH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CE:				CJNE		A, #'E', MOV_CH				; MOV C, E
					MOV			33H, #4BH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CH:				CJNE		A, #'H', MOV_CL				; MOV C, H
					MOV			33H, #4CH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CL:				CJNE		A, #'L', MOV_CM				; MOV C, L
					MOV			33H, #4DH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CM:				CJNE		A, #'M', MOV_CA				; MOV C, M
					MOV			33H, #4EH					; LOAD ITS 8085 INST. SET

MOV_C_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- D -- ;
MOV_D:				CJNE		A, #'D', MOV_E
					D_STR
					DB			'D, ',0						; MOV D, 

MOV_DA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_DA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_DB				; MOV D, A
					MOV			33H, #57H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT
MOV_DB:				CJNE		A, #'B', MOV_DC				; MOV D, B
					MOV			33H, #50H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DC:				CJNE		A, #'C', MOV_DD				; MOV D, C
					MOV			33H, #51H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DD:				CJNE		A, #'D', MOV_DE				; MOV D, D
					MOV			33H, #52H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DE:				CJNE		A, #'E', MOV_DH				; MOV D, E
					MOV			33H, #53H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DH:				CJNE		A, #'H', MOV_DL				; MOV D, H
					MOV			33H, #54H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DL:				CJNE		A, #'L', MOV_DM				; MOV D, L
					MOV			33H, #55H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DM:				CJNE		A, #'M', MOV_DA				; MOV D, M
					MOV			33H, #56H					; LOAD ITS 8085 INST. SET

MOV_D_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- E -- ;
MOV_E:				CJNE		A, #'E', MOV_H
					D_STR
					DB			'E, ',0						; MOV E, 

MOV_EA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_EA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_EB				; MOV E, A
					MOV			33H, #5FH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT
MOV_EB:				CJNE		A, #'B', MOV_EC				; MOV E, B
					MOV			33H, #58H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_EC:				CJNE		A, #'C', MOV_ED				; MOV E, C
					MOV			33H, #59H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_ED:				CJNE		A, #'D', MOV_EE				; MOV E, D
					MOV			33H, #5AH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_EE:				CJNE		A, #'E', MOV_EH				; MOV E, E
					MOV			33H, #5BH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_EH:				CJNE		A, #'H', MOV_EL				; MOV E, H
					MOV			33H, #5CH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_EL:				CJNE		A, #'L', MOV_EM				; MOV E, L
					MOV			33H, #5DH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_EM:				CJNE		A, #'M', MOV_EA				; MOV E, M
					MOV			33H, #5EH					; LOAD ITS 8085 INST. SET

MOV_E_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- H -- ;
MOV_H:				CJNE		A, #'H', MOV_L
					D_STR
					DB			'H, ',0						; MOV H, 

MOV_HA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_HA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_HB				; MOV H, A
					MOV			33H, #67H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT
MOV_HB:				CJNE		A, #'B', MOV_HC				; MOV H, B
					MOV			33H, #60H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HC:				CJNE		A, #'C', MOV_HD				; MOV H, C
					MOV			33H, #61H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HD:				CJNE		A, #'D', MOV_HE				; MOV H, D
					MOV			33H, #62H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HE:				CJNE		A, #'E', MOV_HH				; MOV H, E
					MOV			33H, #63H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HH:				CJNE		A, #'H', MOV_HL				; MOV H, H
					MOV			33H, #64H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HL:				CJNE		A, #'L', MOV_HM				; MOV H, L
					MOV			33H, #65H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HM:				CJNE		A, #'M', MOV_HA				; MOV H, M
					MOV			33H, #66H					; LOAD ITS 8085 INST. SET

MOV_H_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- L -- ;
MOV_L:				CJNE		A, #'L', MOV_M
					D_STR
					DB			'L, ',0						; MOV L, 

MOV_LA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_LA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_LB				; MOV L, A
					MOV			33H, #6FH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT
MOV_LB:				CJNE		A, #'B', MOV_LC				; MOV L, B
					MOV			33H, #68H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LC:				CJNE		A, #'C', MOV_LD				; MOV L, C
					MOV			33H, #69H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LD:				CJNE		A, #'D', MOV_LE				; MOV L, D
					MOV			33H, #6AH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LE:				CJNE		A, #'E', MOV_LH				; MOV L, E
					MOV			33H, #6BH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LH:				CJNE		A, #'H', MOV_LL				; MOV L, H
					MOV			33H, #6CH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LL:				CJNE		A, #'L', MOV_LM				; MOV L, L
					MOV			33H, #6DH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LM:				CJNE		A, #'M', MOV_LA				; MOV L, M
					MOV			33H, #6EH					; LOAD ITS 8085 INST. SET

MOV_L_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- M -- ;
MOV_M:				CJNE		A, #'M', MOV_A_EXTRA		; I PLACED THIS INSTRUCTION DUE TO OUT OF RANGE ERROR
					D_STR										
					DB			'M, ',0						; MOV M, 

MOV_MA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND 
					JNB			01H, MOV_MA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_MB				; MOV M, A
					MOV			33H, #77H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT
MOV_MB:				CJNE		A, #'B', MOV_MC				; MOV M, B
					MOV			33H, #70H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT										
MOV_MC:				CJNE		A, #'C', MOV_MD				; MOV M, C
					MOV			33H, #71H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT										
MOV_MD:				CJNE		A, #'D', MOV_ME				; MOV M, D
					MOV			33H, #72H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT										
MOV_ME:				CJNE		A, #'E', MOV_MH				; MOV M, E
					MOV			33H, #73H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT										
MOV_MH:				CJNE		A, #'H', MOV_ML				; MOV M, H
					MOV			33H, #74H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT										
MOV_ML:				CJNE		A, #'L', MOV_MA				; MOV M, L
					MOV			33H, #75H					; LOAD ITS 8085 INST. SET
															; NOTICE THAT THERE IS NO INSTRUCTION LIKE 'MOV M, M'
MOV_M_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

MOV_A_EXTRA:		AJMP		MOV_A						; THIS INST. WAS TO THE EFFECT OF OUT OF RANGE ERROR

; ***** FOR 'MVI...'
MVI_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
MVI_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, MVI_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', MVI_L2				; MVI A
					MOV			33H, #3EH					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L2:				CJNE		A, #'B', MVI_L3				; MVI B
					MOV			33H, #06H					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L3:				CJNE		A, #'C', MVI_L4				; MVI C
					MOV			33H, #0EH					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L4:				CJNE		A, #'D', MVI_L5				; MVI D
					MOV			33H, #16H					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L5:				CJNE		A, #'E', MVI_L6				; MVI E
					MOV			33H, #1EH					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L6:				CJNE		A, #'H', MVI_L7				; MVI H
					MOV			33H, #26H					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L7:				CJNE		A, #'L', MVI_L8				; MVI L
					MOV			33H, #2EH					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L8:				CJNE		A, #'M', MVI_L1				; MVI M
					MOV			33H, #36H					; LOAD ITS 8085 INST. SET

MVI_L9:				CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'ORA...'
ORA_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
ORA_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, ORA_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', ORA_L2				; ORA A
					MOV			33H, #0B7H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L2:				CJNE		A, #'B', ORA_L3				; ORA B
					MOV			33H, #0B0H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L3:				CJNE		A, #'C', ORA_L4				; ORA C
					MOV			33H, #0B1H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L4:				CJNE		A, #'D', ORA_L5				; ORA D
					MOV			33H, #0B2H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L5:				CJNE		A, #'E', ORA_L6				; ORA E
					MOV			33H, #0B3H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L6:				CJNE		A, #'H', ORA_L7				; ORA H
					MOV			33H, #0B4H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L7:				CJNE		A, #'L', ORA_L8				; ORA L
					MOV			33H, #0B5H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L8:				CJNE		A, #'M', ORA_L1				; ORA M
					MOV			33H, #0B6H					; LOAD ITS 8085 INST. SET

ORA_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'POP...'
POP_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
POP_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, POP_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', POP_L2				; POP B
					MOV			33H, #0C1H					; LOAD ITS 8085 INST. SET
					SJMP		POP_L5
POP_L2:				CJNE		A, #'D', POP_L3				; POP D
					MOV			33H, #0D1H					; LOAD ITS 8085 INST. SET
					SJMP		POP_L5
POP_L3:				CJNE		A, #'H', POP_L4				; POP H
					MOV			33H, #0E1H					; LOAD ITS 8085 INST. SET
					SJMP		POP_L5
POP_L4:				CJNE		A, #'P', POP_L1				; POP PSW
					D_STR
					DB			'PSW',0
					MOV			33H, #0F1H					; LOAD ITS 8085 INST. SET

POP_L5:				CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ***** FOR 'PUSH...'
PUSH_:				MOV			A, #' '					    ; GIVE SPACE
					CALL		LCD_SHO
PUSH_L1:			CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, PUSH_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', PUSH_L2			; PUSH B
					MOV			33H, #0C5H					; LOAD ITS 8085 INST. SET
					SJMP		PUSH_L5
PUSH_L2:			CJNE		A, #'D', PUSH_L3			; PUSH D
					MOV			33H, #0D5H					; LOAD ITS 8085 INST. SET
					SJMP		PUSH_L5
PUSH_L3:			CJNE		A, #'H', PUSH_L4			; PUSH H
					MOV			33H, #0E5H					; LOAD ITS 8085 INST. SET
					SJMP		PUSH_L5
PUSH_L4:			CJNE		A, #'P', PUSH_L1			; PUSH PSW
					D_STR
					DB			'PSW',0
					MOV			33H, #0F5H					; LOAD ITS 8085 INST. SET

PUSH_L5:			CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'SBB...'
SBB_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
SBB_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, SBB_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', SBB_L2				; SBB A
					MOV			33H, #9FH					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L2:				CJNE		A, #'B', SBB_L3				; SBB B
					MOV			33H, #98H					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L3:				CJNE		A, #'C', SBB_L4				; SBB C
					MOV			33H, #99H					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L4:				CJNE		A, #'D', SBB_L5				; SBB D
					MOV			33H, #9AH					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L5:				CJNE		A, #'E', SBB_L6				; SBB E
					MOV			33H, #9BH					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L6:				CJNE		A, #'H', SBB_L7				; SBB H
					MOV			33H, #9CH					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L7:				CJNE		A, #'L', SBB_L8				; SBB L
					MOV			33H, #9DH					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L8:				CJNE		A, #'M', SBB_L1				; SBB M
					MOV			33H, #9EH					; LOAD ITS 8085 INST. SET

SBB_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ***** FOR 'SUB...'
SUB_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
SUB_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, SUB_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', SUB_L2				; SUB A
					MOV			33H, #97H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L2:				CJNE		A, #'B', SUB_L3				; SUB B
					MOV			33H, #90H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L3:				CJNE		A, #'C', SUB_L4				; SUB C
					MOV			33H, #91H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L4:				CJNE		A, #'D', SUB_L5				; SUB D
					MOV			33H, #92H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L5:				CJNE		A, #'E', SUB_L6				; SUB E
					MOV			33H, #93H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L6:				CJNE		A, #'H', SUB_L7				; SUB H
					MOV			33H, #94H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L7:				CJNE		A, #'L', SUB_L8				; SUB L
					MOV			33H, #95H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L8:				CJNE		A, #'M', SUB_L1				; SUB M
					MOV			33H, #96H					; LOAD ITS 8085 INST. SET

SUB_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ***** FOR 'STAX...'
STAX_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
STAX_L1:			CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, STAX_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', STAX_L2			; STAX B
					MOV			33H, #02H					; LOAD ITS 8085 INST. SET
					SJMP		STAX_L3
STAX_L2:			CJNE		A, #'D', STAX_L1			; STAX D
					MOV			33H, #12H					; LOAD ITS 8085 INST. SET

STAX_L3:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'XRA...'
XRA_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
XRA_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, XRA_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', XRA_L2				; XRA A
					MOV			33H, #0AFH					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L2:				CJNE		A, #'B', XRA_L3				; XRA B
					MOV			33H, #0A8H					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L3:				CJNE		A, #'C', XRA_L4				; XRA C
					MOV			33H, #0A9H					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L4:				CJNE		A, #'D', XRA_L5				; XRA D
					MOV			33H, #0AAH					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L5:				CJNE		A, #'E', XRA_L6				; XRA E
					MOV			33H, #0ABH					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L6:				CJNE		A, #'H', XRA_L7				; XRA H
					MOV			33H, #0ACH					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L7:				CJNE		A, #'L', XRA_L8				; XRA L
					MOV			33H, #0ADH					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L8:				CJNE		A, #'M', XRA_L1				; XRA M
					MOV			33H, #0AEH					; LOAD ITS 8085 INST. SET

XRA_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ------------------------------------------ END OF CHARACTER KEY COMBINATION ----------------------------------------------------------

; ================================================ INTERRUPT SUBROUTINES (ISRs) ========================================================
SECOND_FUNCTION:
					LCALL 		DELAY_500mS					; DELAY_500mS = 500ms
					LCALL 		KEYPAD_ID					; CALL THE KEYPAD TO SUPPLY THE ASCII OF THE KEY DEPRESSED
					DJNZ		30H, SECOND_FUNCTION		; MAKE THE SECOND FUNCTION ACTIVE FOR ABOUT 2 SECONDS
					JNB			01H, EXIT_SECOND_FUNCTION	; IF NO KEY IS DEPRESSED AFTER 2 SECONDS, EXIT ELSE CONTINUE
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'M', SF_1
					LCALL		SUB_MEM						; CALL SUBTITUTE MEMORY OSR
					SJMP		EXIT_SECOND_FUNCTION	

SF_1:				CJNE		A, #'X', SF_2
					LCALL		EXE							; CALL EXECUTE OSR
					SJMP		EXIT_SECOND_FUNCTION
												
SF_2:				CJNE		A, #'N', SF_3
					LCALL		CANCEL						; CALL CANCEL OSR
					MOV			SP, #57H					; INITIALIZATION OF THE TOP OF THE STACK(40 BYTES OF MEM. ARE AVAILABLE ON THIS INITIALIZATION)
					JMP			MAIN2						; START AFRESH

;SF_3:				CJNE		A, #'C', SF_4 
;					LCALL		CPLT						; CALL CPLT (CODE OR PROGRAMMING LANGUAGE TYPE) OSR
;					SJMP		EXIT_SECOND_FUNCTION
					 
SF_3:				CJNE		A, #'B', SF_4 
					LCALL		STEP						; CALL STEP-BY-STEP EXECUTION OSR
					SJMP		EXIT_SECOND_FUNCTION

SF_4:				CJNE		A, #'Z', SF_5 
					LCALL		EXAM_REG					; CALL EXAM_REG SR
					SJMP		EXIT_SECOND_FUNCTION

SF_5:				CJNE		A, #'V', SF_6 
					LCALL		V_HEX						; CALL V_HEX (VIEW HEXCODE) OSR
					SJMP		EXIT_SECOND_FUNCTION

SF_6:				CJNE		A, #'*', EXIT_SECOND_FUNCTION 
					LCALL		E_N_D						; CALL E_N_D (END PROGRAM) OSR
					
EXIT_SECOND_FUNCTION:
				   	RETI

; ================================================ ORDINARY SUBROUTINES (OSRs) ==========================================================

; ---------------------------------------------------------------------------------------------------------------------------------------
DELAY_1:
; THIS SUBROUTINE PROVIDES A DELAY OF 500ms TO ENSURE THAT THE SECOND FUNCTION IS ON FOR AT LEAST 2sec (ie 4 X 500ms)

; ---------------------------------------------------------------------------------------------------------------------------------------
FLY_ADDRESS:

; ---------------------------------------------------------------------------------------------------------------------------------------
FLY_DATA:		

; ---------------------------------------------------------------------------------------------------------------------------------------
FLY_OPCODE:

; ---------------------------------------------------------------------------------------------------------------------------------------
DISP_CHAR:
        			POP     	DPH
        			POP     	DPL
PRINT_TEXT:
        			CLR     	A
        			MOVC    	A, @A+DPTR
       				CJNE    	A, #00H, LOOP
       				SJMP    	RETURN
LOOP:  				LCALL  		LCD_SHO
        			INC     	DPTR
        			LJMP    	PRINT_TEXT
RETURN: 			MOV     	A, #01H
        			JMP     	@A+DPTR

; ---------------------------------------------------------------------------------------------------------------------------------------
GET_READY:
; THIS SUBROUTINE CHECKS BUSY FLAG (P0.7=D7) TO ENABLE COMMAND OR DATA LATCH-IN
; SFR BITS: P0.7 (D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
					SETB 		P0.7 						; MAKE P1.7 INPUT PORT
					CLR 		P2.5	 					; RS=0 ACCESS LCD COMMAND REG
					SETB 		P2.6 						; R/W=1 READ COMMAND REG
															; READ COMMAND REG AND CHECK BUSY FLAG
BACK:	
					CLR 		P3.3	 					; E=0 L-TO-H PULSE
					SETB 		P3.3 						; E=1 FOR L-TO-H PULSE
					JB 			P0.7, BACK					; STAY UNTIL BUSY FLAG=0
					RET										; RETURN TO THE CALLER PROGRAM

; ---------------------------------------------------------------------------------------------------------------------------------------
INTRO_CPLT:			
;					MOV			A, #80H						; THIS INSTRUCTION MY NOT BE RELEVANT SINCE THIS MESSAGE IS CALLED IMMEDIATELY AFTER 
					D_STR									; A LCD SCREEN CLEAR THUS DDRAM ADDRESS AUTOMATICALLY RESETS TO LINE 1
					DB			'   SBC 8085uP   ',0		; LINE 1
					MOV			A, #0C0H					; SET DDRAM ADDRESS TO LINE 2
					CALL		LCD_CMD				  
					D_STR									; DISPLAY THE FOLLOWING STRINGS
					DB			'by IFEDIORA E.C.',0		; LINE 2
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
INTRO_MSG:
;
;
;					MOV			A, #80H						; THIS INSTRUCTION MY NOT BE RELEVANT SINCE THIS MESSAGE IS CALLED IMMEDIATELY AFTER 
					D_STR									; A LCD SCREEN CLEAR THUS DDRAM ADDRESS AUTOMATICALLY RESETS TO LINE 1
					DB			'Press 0 for MHEX',0		; LINE 1
					MOV			A, #0C0H					; SET DDRAM ADDRESS TO LINE 2
					CALL		LCD_CMD				  
					D_STR									; DISPLAY THE FOLLOWING STRINGS
					DB			'Press 1 for ASM',0		    ; LINE 2
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
INTRO_SUBMEM_REQUEST:
;				
					D_STR									; DISPLAY THE FOLLOWING STRINGS 
					DB			'Enter Start Addr',0		; LINE 1
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_CMD:
; THIS SUBROUTINE SENDS THE ASCII CODE FOR THE COMMAND CHARATER TO BE DISPLAYED ON THE LCD
; IT CALLS READY (OSR) TO CHECK BUSY FLAG FOR COMMAND TO BE LATCHED-IN
; OPERATING REGISTER: A
; SFR BITS: P0 (LCD DATA PORT D0-D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
 
					ACALL 		GET_READY 					; IS LCD READY?
					MOV   		P0, A						; LATCH COMMAND INTO LCD DATA PORT	  
					CLR   		P2.5						; RS=0 ACCESS LCD DATA REG
					CLR			P2.6						; WRITE
					SETB  	 	P3.3						; H-TO-L PULSE TO LATCH-IN
					CLR   		P3.3						; H-TO-L PULSE TO LATCH-IN
					RET										; RETURN TO THE CALLER PROGRAM

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_SET:
; THIS SUBROUTINE SETS THE MODE OF OPERATION OF THE LCD
; IT CALLS LCD_CMD OSR TO LATCH-IN THE COMMAND
; OPERATING REGISTER: A
					MOV   	`	A, #38H						; 5 X 7 MATRIX DISPLAY
					CALL   		LCD_CMD						; LATCH COMMAND JUST ABOVE INTO THE LCD
					MOV   		A, #80H						; DISPLAY ON LINE 1
					CALL   		LCD_CMD						; LATCH COMMAND JUST ABOVE INTO THE LCD
					MOV   		A, #06H						; INCREMENT FROM LEFT TO RIGHT
					CALL   		LCD_CMD						; LATCH COMMAND JUST ABOVE INTO THE LCD
					RET										; RETURN TO THE CALLER PROGRAM

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_SHO:
; THIS SUBROUTINE SENDS THE ASCII CODE FOR THE DATA CHARATER TO BE DISPLAYED ON THE LCD
; IT CALLS READY (OSR) TO CHECK BUSY FLAG FOR DATA TO BE LATCHED-IN
; OPERATING REGISTER: A
; SFR BITS: P0 (LCD DATA PORT D0-D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
					ACALL 		GET_READY 					; IS LCD READY?
					MOV   		P0, A						; LATCH DATA INTO LCD DATA PORT	
					SETB   		P2.5						; RS=1, ACCESS LCD DATA REG
					CLR			P2.6						; R/!W=0, WRITE
					SETB   		P3.3						; H-TO-L PULSE TO LATCH-IN
					CLR   		P3.3						; H-TO-L PULSE TO LATCH-IN
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
ROW_1: 				DB 			'0','1','2','3','4','5','6','7'		; DATA STORED IN ASCII CODE
ROW_2: 				DB 			'E','R','T','U','I','O','P','8'
ROW_3: 				DB 			'A','S','D','F','H','J','L','9'
ROW_4: 				DB 			'Z','X','C','V','B','N','M','*'		; '*' IS RESERVED FOR THE FUNCTION 'NEXT'
					END