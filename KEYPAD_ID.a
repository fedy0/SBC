;				ROW 	EQU  	P3
;				COL		EQU		P1	
   				ORG   	0000H
				JMP   	MAIN
;------------------------------
   				ORG   	30H
MAIN:
				CALL   	LCD_DLY	
				CALL   	LCD_SET
M1:
				CALL   	KEYPAD_ID
				SJMP   	M1

KEYPAD_ID:
; THIS SUBROUTINE RETRIEVES DATA FROM THE KEYPAD AND IDENTIFIES THE KEY PRESSED
; IT STORES THE ASCII CODE OF THE KEY PRESSED IN THE CHARACTER DISPLAY MEMORY (ie CDM 31H)
; IT ALSO HAS IN IT SOME STATUTORY FLAGS SUCH AS: 01H(KEY PRESSED FLAG),
; ALSO HAS IN IT SOME STATUTORY MEMORY LOC SUCH AS: 30H(SUB MEM DELAY COUNTER 4 X 500ms), LOAD #01H IF KEY IS PRESSED

; ****************************** KEYPAD_ID
				MOV   	P1, #00H				; MAKE P1 OUTPUT
				MOV		P3, #0FFH				; MAKE P3.0, P3.1, P3.4 & P3.5 INPUT PORTS AND SECURE THE OTHER PINS' SETTINGS
				MOV   	A, P3			 		; READ THE ROW
;				ANL  	A,#0FFH				 	; MASK THE 4 MSB (3 COLUMNS & 1(P1.7) EMPTY PIN)
				CJNE  	A,#0FFH,KEY2				; IS ANY KEY DEPRESSED? IF 'NO' RETURN TO KEYPAD_ID ELSE JUMP TO KEY2 FOR COMFIRMATION
				JMP   	KEYFNL					; THE ABOVE SEGMENT ENSURES THAT KEYPAD IS FREE BEFORE A NEW SCAN IS CARRIED OUT
KEY2:	
				CALL  	LCD_DLY				 	; DELAY TO DEBOUNCE KEYPAD
				MOV   	P1, #00H				; MAKE P1 OUTPUT
				MOV		P3, #0FFH				; MAKE P3.0, P3.1, P3.4 & P3.5 INPUT PORTS AND SECURE THE OTHER PINS' SETTINGS
				MOV   	A,P3				 	; READ THE ROW AGAIN TO COMFIRM KEY DEPRESSED 
;				ANL   	A,#0FFH					; MASK THE FOLLOWING BITS' RESULTS READ FROM P3: D2, D3, D6 & D7 (THEY ARE NOT FROM ROW PINS)
				CJNE  	A,#0FFH,KEY3			; IS ANY KEY DEPRESSED? IF 'NO' RETURN TO KEYPAD_ID ELSE JUMP TO KEY3 FOR IDENTIFICATION
				JMP   	KEYFNL
; ****************************** ROW SCAN STARTS
KEY3:
				MOV   	R5,#06H					; LOAD 6 INTO R5 FOR ROW SCAN (NEEDED SCAN = 4 OF 6; THE OTHER 2 AT THE MIDDLE ARE USELESS)
				ORL		A, #0CCH				; #0CCH = 11001100B. THIS IS DONE TO PURPOSELY SKIP (PARTICULARLY) P3.2 & P3.3
												; P3.6 & P3.7 HAS BEEN TAKEN CARE OF (ie SKIP) BY THE BOTH INSTRUCTIONS JUST ABOVE
KEY31:	
				RRC   	A						; SCAN EACH OF THE 4 ROWS
				JNC   	KEY4					; IF CY = 0, A KEY HAS BEEN DEPRESSED ON THAT ROW JUMP TO KEY4 ELSE CONTINUE
				DJNZ  	R5,KEY31				; SCAN NEXT ROW
KEY4:
				CJNE  	R5,#6,KEY41				; IF R5 = 6 LOAD ROW_1 ADDRESS AND JUMP TO KEY41 ELSE JUMP TO KEY5
				MOV   	DPTR,#ROW_1
				JMP   	KEY5
KEY41:	
				CJNE  	R5,#5,KEY42				; IF R5 = 5 LOAD ROW_2 ADDRESS AND JUMP TO KEY42 ELSE JUMP KEY5
				MOV   	DPTR,#ROW_2
				JMP   	KEY5
KEY42:	
				CJNE  	R5,#2,KEY43				; IF R5 = 2 LOAD ROW_3 ADDRESS AND JUMP TO KEY43 ELSE JUMP KEY5
				MOV   	DPTR,#ROW_3
				JMP   	KEY5
KEY43:	
				CJNE  	R5,#1,KEY44				; IF R5 = 1 LOAD ROW_4 ADDRESS AND JUMP TO KEY44 ELSE JUMP KEY5
				MOV   	DPTR,#ROW_4
				JMP   	KEY5
KEY44:											
				JMP  	KEYFNL					; ERROR! RETURN TO KEYPAD_ID (NO KEY DEPRESSED)
; *************************** COLUMN SCAN STARTS
KEY5:									
				MOV   	P3, #0FFH				; MAKE ALL INPUT (IT MAY MEAN CLEAR, JUST COMFIRM LATER!)
				MOV   	P1, #00H				;  
				MOV		P3, #0FFH				; MAKE P3 OUTPUT NOW
				MOV   	A, P1					; READ P1
KEY6:										
				MOV   	R5,#9					; LOAD 9 INTO R5 FOR COLUMN SCAN
KEY61:	
				RRC   	A						; SCAN EACH OF THE 8 COLUMNS
				JNC   	KEY7					; IF CY = 0, A KEY HAS BEEN DEPRESSED ON THAT COLUMNS JUMP TO KEY7 ELSE CONTINUE
				DJNZ  	R5,KEY61				; SCAN NEXT COLUMN
				JMP   	KEYFNL					; ERROR! RETURN TO KEYPAD_ID (NO KEY DEPRESSED)
; *****************************LOAD DATA ADDRESS	
KEY7:
				CJNE  	R5,#9,KEY71				; IF R5 ~= 9 CONTINUE ELSE JUMP TO KEY71
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA. REMEMBER DPTR CONTAINS X00H ADRRESS HERE
												; THUS THE DISPARITY WHILE INCREMENT OCCUR ALONG (DOWN THE PROGRAM)
KEY71:	
				CJNE 	R5,#8,KEY72				; IF R5 ~= 8 CONTINUE ELSE JUMP TO KEY72
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR ONCE FOR COLUMN 2
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY72:	
				CJNE  	R5,#7,KEY73				; IF R5 ~= 7 CONTINUE ELSE JUMP TO KEY73
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR TWICE FOR COLUMN 3
				INC   	DPTR
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY73:	
				CJNE  	R5,#6,KEY74 			; IF R5 ~= 6 CONTINUE ELSE JUMP TO KEY74
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR THRICE FOR COLUMN 4
				INC   	DPTR
				INC   	DPTR	
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY74:	
				CJNE  	R5,#5,KEY75 			; IF R5 ~= 5 CONTINUE ELSE JUMP TO KEY75
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR 4 TIMES FOR COLUMN 5
				INC   	DPTR
				INC   	DPTR	
				INC   	DPTR
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY75:	
				CJNE  	R5,#4,KEY76 			; IF R5 ~= 4 CONTINUE ELSE JUMP TO KEY76
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR 5 TIMES FOR COLUMN 6
				INC   	DPTR
				INC   	DPTR	
				INC   	DPTR
				INC   	DPTR
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY76:	
				CJNE  	R5,#3,KEY77 			; IF R5 ~= 3 CONTINUE ELSE JUMP TO KEY77
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR 6 TIMES FOR COLUMN 7
				INC   	DPTR
				INC   	DPTR	
				INC   	DPTR
				INC   	DPTR
				INC   	DPTR
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY77:	
				CJNE  	R5,#2,KEY78 			; IF R5 ~= 2 CONTINUE ELSE JUMP TO KEY78
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR 7 TIMES FOR COLUMN 8
				INC   	DPTR
				INC   	DPTR
				INC   	DPTR
				INC   	DPTR
				INC   	DPTR
				INC   	DPTR	
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY78:
				JMP   	KEYFNL					; RETURN TO KEYPAD_ID
KEY8:
				MOV   	P1, #00H				; MAKE P1 OUTPUT
				MOV		P3, #0F7H				; MAKE P3.0, P3.1, P3.4 & P3.5 INPUT PORTS AND SECURE THE OTHER PINS' SETTINGS
				MOV   	A, P3			 		; READ THE ROW
				CJNE  	A,#33H,KEY8				; IS ANY KEY DEPRESSED? IF 'NO' RETURN TO KEYPAD_ID ELSE JUMP TO KEY2 FOR COMFIRMATION
												; THE 4 INSTRUCTIONS JUST ABOVE IS USED TO PREVENT REPETITIVE DISPLAY ON KEY HOLD DOWN

				MOV   	A,#0					; CLEAR THE ACCUMULATOR
				MOVC  	A,@A+DPTR				; LOAD THE CODE FOR DISPLAY
				CALL  	LCD_SHO					; CALL SUBROUTINE TO DISPLAY DATA

KEYFNL:
				RET								; RETURN TO KEYPAD_ID

; ---------------------------------------------------------------------------------------------------------------------------------------
GET_READY:
; THIS SUBROUTINE CHECKS BUSY FLAG (P0.7=D7) TO ENABLE COMMAND OR DATA LATCH-IN
; SFR BITS: P0.7 (D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
					SETB 		P0.7 						; MAKE P0.7 INPUT PORT
					CLR 		P2.5	 					; RS=0 ACCESS LCD COMMAND REG
					SETB 		P2.6 						; R/W=1 READ COMMAND REG
															; READ COMMAND REG AND CHECK BUSY FLAG
BACK:	
					CLR 		P3.3	 					; E=0 L-TO-H PULSE
					SETB 		P3.3 						; E=1 FOR L-TO-H PULSE
					JB 			P0.7, BACK					; STAY UNTIL BUSY FLAG=0
					RET										; RETURN TO THE CALLER PROGRAM

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_CMD:
; THIS SUBROUTINE SENDS THE ASCII CODE FOR THE COMMAND CHARATER TO BE DISPLAYED ON THE LCD
; IT CALLS READY (OSR) TO CHECK BUSY FLAG FOR COMMAND TO BE LATCHED-IN
; OPERATING REGISTER: A
; SFR BITS: P0 (LCD DATA PORT D0-D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
 
					ACALL 		GET_READY 					; IS LCD READY?
					MOV   		P0, A						; LATCH COMMAND INTO LCD DATA PORT	  
					CLR   		P2.5						; RS=0 ACCESS LCD COMMAND REG
					CLR			P2.6						; WRITE
					SETB  	 	P3.3						; H-TO-L PULSE TO LATCH-IN
					CLR   		P3.3						; H-TO-L PULSE TO LATCH-IN
					RET										; RETURN TO THE CALLER PROGRAM
; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_DLY:
					MOV   R6,#50
HERE2:
					MOV   R7,#50
HERE1:
					DJNZ   R7,HERE1	
					DJNZ   R6,HERE2
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_SET:
; THIS SUBROUTINE SETS THE MODE OF OPERATION OF THE LCD
; IT CALLS LCD_CMD OSR TO LATCH-IN THE COMMAND
; OPERATING REGISTER: A
					MOV   	A, #38H					; 5 X 7 MATRIX DISPLAY
					CALL   	LCD_CMD					; LATCH COMMAND JUST ABOVE INTO THE LCD
					MOV   	A, #0CH					; DISPLAY ON SECOND LINE
					CALL   	LCD_CMD					; LATCH COMMAND JUST ABOVE INTO THE LCD
					MOV   	A, #06H					; INCREMENT FROM LEFT TO RIGHT
					CALL   	LCD_CMD					; LATCH COMMAND JUST ABOVE INTO THE LCD
					RET								; RETURN TO THE CALLER PROGRAM

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_SHO:
; THIS SUBROUTINE SENDS THE ASCII CODE FOR THE DATA CHARATER TO BE DISPLAYED ON THE LCD
; IT CALLS READY (OSR) TO CHECK BUSY FLAG FOR DATA TO BE LATCHED-IN
; OPERATING REGISTER: A
; SFR BITS: P0 (LCD DATA PORT D0-D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
					ACALL 		GET_READY 					; IS LCD READY?
					MOV   		P0, A						; LATCH DATA INTO LCD DATA PORT	
					SETB   		P2.5						; RS=1, ACCESS LCD DATA REG
					CLR			P2.6						; R/!W=0, WRITE
					SETB   		P3.3						; H-TO-L PULSE TO LATCH-IN
					CLR   		P3.3						; H-TO-L PULSE TO LATCH-IN
					RET

; **********************************************
ROW_1: 				DB 			'0','1','2','3','4','5','6','7'		; DATA STORED IN ASCII CODE
ROW_2: 				DB 			'E','R','T','U','I','O','P','8'
ROW_3: 				DB 			'A','S','D','F','H','J','L','9'
ROW_4: 				DB 			'Z','X','C','V','B','N','M','*'		; '*' IS RESERVED FOR THE FUNCTION 'NEXT'
					END