; THIS PROGRAM IS WRITTEN TO SATISFACTORILY GENERATE ALL THE INSTRUCTION SET (246) OF THE 8085 MICROPROCESSOR

; ================================================ MEMORY LOCATIONS ====================================================================
;					SMDC		EQU		30H					; SUB MEM DELAY COUNTER 4 X 500ms 
;					CDM			EQU		31H					; CHARACTER DISPLAY MEMORY (ACTS LIKE A TEMPORARY SAFE)
;					NC			EQU		32H					; NIBBLE COUNTER (THE NO. OF INTENDED NIBBLE TO BE OBTAINED IS LOADED IN IT)
;					BYTE1		EQU		33H					; 1ST BYTE CODE'S TEMPORARY LOCATION (FOR OPCODE ONLY)
;					BTYE2		EQU		34H					; 2ND BYTE CODE'S TEMPORARY LOCATION (FOR DATA OR LOWER ORDER BYTE OF AN ADDRESS)
;					BYTE3		EQU  	35H					; 3RD BYTE CODE'S TEMPORARY LOCATION (FOR THE HIGH ORDER BYTE OF AN ADDRESS)
;					H2AIM		EQU		36H					; HEX_2_ASCII INPUT MEMORY 
; 					CH2ALOB	   	EQU		37H					; CONVERTED HEX_2_ASCII LOW ORDER BYTE (CONTENT IS IN ASCII, READY FOR DISPLAY)
; 					CH2AHOB	   	EQU		38H					; CONVERTED HEX_2_ASCII HIGH ORDER BYTE (CONTENT IS IN ASCII, READY FOR DISPLAY)
;					NAHLOB		EQU		39H					; NEXT ADDRESS HOLDERS FOR LOB OR ADDRESS_DISPLAY_CONTROL'S INPUT MEM LOC 1 (THEY TEMPORARILY STORE THE CURRENT ADDRESS WHEN WRITING PROGRAM)
;					NAHHOB		EQU		3AH					; NEXT ADDRESS HOLDERS FOR HOB OR ADDRESS_DISPLAY_CONTROL'S INPUT MEM LOC 2
;					MHC			EQU		3BH					; M_HEX DIGIT COUNTER
;					VHADM1		EQU		3CH					; V_HEX ADDRESS DISPLAY MEMORY LOC. 1 FOR LOB
;					VHADM2		EQU		3DH					; V_HEX ADDRESS DISPLAY MEMORY LOC. 2 FOR HOB
;					SASML1		EQU		3EH					; START'S ADDRESS STORAGE MEM LOC. 1 FOR LOB (STORES THE BEGINNING ADDRESS)
;					SASML2		EQU		3FH					; START'S ADDRESS STORAGE MEM LOC. 2 FOR HOB (STORES THE BEGINNING ADDRESS)
;					EASML1		EQU		40H					; END'S ADDRESS STORAGE MEM LOC. 1 FOR LOB (STORES THE LAST/END ADDRESS)
;					EASML2		EQU		41H					; END'S ADDRESS STORAGE MEM LOC. 2 FOR HOB (STORES THE LAST/END ADDRESS)
; THE ADDRESS OF THE RESERVED AREAS CONTAINING THE RESULTS (OR CONTENT) OF THE EXAMINED REGISTERS ARE SAVED IN THE FOLLOWING MEMORY LOCATIONS
; 					PAM1		EQU		42H					; PAGE/SCREEN ADDRESS MEMORY LOCATION 1 FOR LOB(FOR CANCEL SR ONLY) = EXAMINED REGISTER A (LOB ADDRESS)
;					PAM2		EQU		43H					; PAGE/SCREEN ADDRESS MEMORY LOCATION 2 FOR HOB(FOR CANCEL SR ONLY)	= EXAMINED REGISTER A (HOB ADDRESS)
;					EXRB1		EQU		44H					; EXAMINED REGISTER B (LOB ADDRESS)
;					EXRB2		EQU		45H					; EXAMINED REGISTER B (HOB ADDRESS)
;					EXRC1		EQU		46H					; EXAMINED REGISTER C (LOB ADDRESS)
;					EXRC2		EQU		47H					; EXAMINED REGISTER C (HOB ADDRESS)
;					EXRD1		EQU		48H					; EXAMINED REGISTER D (LOB ADDRESS)
;					EXRD2		EQU		49H					; EXAMINED REGISTER D (HOB ADDRESS)
;					EXRE1		EQU		4AH					; EXAMINED REGISTER E (LOB ADDRESS)
;					EXRE2		EQU		4BH					; EXAMINED REGISTER E (HOB ADDRESS)
;					EXRH1		EQU		4CH					; EXAMINED REGISTER H (LOB ADDRESS)
;					EXRH2		EQU		4DH					; EXAMINED REGISTER H (HOB ADDRESS)
;					EXRL1		EQU		4EH					; EXAMINED REGISTER L (LOB ADDRESS)
;					EXRL2		EQU		4FH					; EXAMINED REGISTER L (HOB ADDRESS)
;					DML1		EQU		50H					; DELAY'S MEM LOCATION 1
;					DML2		EQU		51H					; DELAY'S MEM LOCATION 2
;					DML3		EQU		52H					; DELAY'S MEM LOCATION 3

; ================================================= FLAG LOCATIONS =====================================================================
; 					SMF			BIT		00H					; SUB MEM FLAG
;					KPF			BIT		01H					; KEY PRESSED FLAG
;					HNF			BIT		02H					; HEX NIBBLE FLAG
;					NTF			BIT		03H					; NEXT TYPE FLAG (OPCODE TYPE 03H = 0, OPERAND TYPE 03H = 1)
;					BIF			BIT		04H					; BYTE INDICATOR FLAG (INDICATES WHEN AN OPERAND IS A 2 BYTE(4 NIBBLES) OR 1 BYTE (2NIBBLES) )
;					NMCF		BIT		05H					; NIBBLE MARRIAGE CONTROL FLAG
;					MCF			BIT		06H					; MARRIAGE COMPLETION FLAG ONLY FOR HIGH ORDER BYTE (MCF = 1 ON MARRIAGE COMPLETION)
;					NOTF		BIT		07H					; NEXT OPERAND TYPE FLAG (DATA TYPE OPERAND 07H = 0, ADDRESS TYPE OPERAND 07H = 1)
; 					NSF			BIT		08H					; NEXT SUB MEM FLAG (SELECTS THE PART OF THE NEXT SR MEANT FOR SUB MEM)
;					CPLTF		BIT		09H					; CODE/PROGRAMMING LANGUAGE TYPE FLAG
;					MHF			BIT		0AH					; M_HEX FLAG FOR SWAP SELECTION (HELPS TO FORMAT DATA IN MHEX SR)		
;					VHDF		BIT		0BH					; V_HEX DECREMENT FLAG
;					EF			BIT		0CH					; END'S FLAG

; ==================================================== MACROS ==========================================================================
CLR_LCD    			MACRO									; CLEAR LCD
        			MOV     	A, #01H
       				LCALL   	LCD_CMD																			
           			ENDM  
; --------------------------------------------------------------------------------------------------------------------------------------
D_STR     			MACRO									; DISPLAY STRINGS OF CHARACTER
       				LCALL    	LCD_CMD
        			LCALL    	DISP_CHAR
           			ENDM
; ========================================================  MAIN  ======================================================================
					ORG			0000H
					JMP			MAIN						; ON SYSTEM RESET, JUMP TO MAIN
					
					ORG			0003H
					JMP			SECOND_FUNCTION				; ON SYSTEM EXTERNAL INTERRUPT 0, JUMP TO THE ISR 'SECOND_FUNCTION'

					ORG			0030H
MAIN:														; THE MAIN PROGRAM BEGINS HERE
					MOV			SP, #57H					; INITIALIZATION OF THE TOP OF THE STACK(40 BYTES OF MEM. ARE AVAILABLE ON THIS INITIALIZATION)
					LCALL 		LCD_SET						; SET THE LCD FOR PROPER PERFORMANCE
					LCALL		INTRO_MSG					; CALLS AN OSR TO DISPLAY LINE 1: '   SBC 8085uP   '
															;                         LINE 2: 'by IFEDIORA E.C.'  OR 'by FEDYRONIX INC'
MAIN1:				CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED TO CONTINUE
					JNB			01H, MAIN1
					CLR			01H							; GET READY FOR NEXT KEY
															
					CLR_LCD									; CLEAR THE LCD (NOTE THIS RESET THE ADDRESS OF THE DDRAM TO 80H
					LCALL		INTRO_CPLT					; CALLS AN OSR TO DISPLAY LINE 1: 'Press 0 for MHEX'
															;                         LINE 2: 'Press 1 for ASM' 
MAIN1_1:			CALL		KEYPAD_ID					; ENSURE THAT EITHER '0' OR '1' KEY IS DEPRESSED
					JNB			01H, MAIN1_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'0', MAIN1_2
					CLR			09H							; SELECTS MHEX
					MOV			3BH, #02H					; MOVE '2' INTO THE MHEX COUNTER
					SJMP		MAIN1_3
MAIN1_2:			CJNE		A, #'1', MAIN1_1
					SETB		09H							; SELECTS ASM

MAIN1_3:			MOV 		IE, #10000001B				; ENABLE THE !INT0 EXTERNAL INTERRUPT (SECOND_FUNCTION ISR)

					CLR_LCD
					LCALL		INTRO_SUBMEM_REQUEST		; CALLS AN OSR TO DISPLAY ON LINE 1: 'Enter start addr'

					MOV			30H,#04H					; LOAD '4' INTO THE COUNTER 
					JNB			00H, $						; STAY HERE TILL THE SUB MEM IS PRESSED


MAIN2:				MOV			A, #0C0H					; INSTRUCTION/COMMAND TO CARRY OUT DISPLAY ON LINE 2
					CALL		LCD_CMD

					JNB			09H, M_HEX_OUT_OF_RANGE		; USE MACHINE LANGUAGE FOR 09H = 0 ELSE USE ASM FOR 09H = 1


; =*=*=*=*=*=*=*=*=*=*=*=*=*        ASSEMBLY LANGUAGE AS THE CODE/PROGRAMMING LANGUAGE TYPE (CPLT)        =*=*=*=*=*=*=*=*=*=*=*=*=*=
; ---------------------------------------------- FIRST CHARATER KEY COMBINATION -----------------------------------------------------


ASM:				CALL		KEYPAD_ID					; ENSURE A KEY (1ST KEY) IS DEPRESSED
					JNB			01H, ASM
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', ASM1_1				; JUMP TO A'S SECOND CHARACTER ELSE CONTINUE
					JMP			A2
ASM1_1:				CJNE		A, #'C', ASM1_2				; JUMP TO C'S SECOND CHARACTER ELSE CONTINUE 
					JMP			C2
ASM1_2:				CJNE		A, #'D', ASM1_3				; JUMP TO D'S SECOND CHARACTER ELSE CONTINUE 
					JMP			D2
ASM1_3:				CJNE		A, #'E', ASM1_4				; EVALUATE E (ie EI) ELSE CONTINUE
					CALL		LCD_SHO
					MOV			A, #'I'
					MOV			33H, #0FBH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; EXPORT THE OPCODE
					SJMP		MAIN2

ASM1_4:				CJNE		A, #'H', ASM1_5				; EVALUATE H (ie HLT) ELSE CONTINUE
					CALL		LCD_SHO
					MOV			A, #'L'
					CALL		LCD_SHO
					MOV			A, #'T'
					MOV			33H, #76H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; EXPORT THE OPCODE
					SJMP		MAIN2

ASM1_5:				CJNE		A, #'I', ASM1_6				; JUMP TO I'S SECOND CHARACTER ELSE CONTINUE 
					JMP			I2
ASM1_6:				CJNE		A, #'J', ASM1_7				; JUMP TO J'S SECOND CHARACTER ELSE CONTINUE 
					JMP			J2
ASM1_7:				CJNE		A, #'L', ASM1_8				; JUMP TO L'S SECOND CHARACTER ELSE CONTINUE 
					JMP			L2
ASM1_8:				CJNE		A, #'M', ASM1_9				; JUMP TO M'S SECOND CHARACTER ELSE CONTINUE 
					JMP			M2

ASM1_9:				CJNE		A, #'N', ASM1_10			; EVALUATE N (ie NOP) ELSE CONTINUE
					CALL		LCD_SHO
					MOV			A, #'O'
					CALL		LCD_SHO
					MOV			A, #'P'
					MOV			33H, #00H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; EXPORT THE OPCODE
					SJMP		MAIN2

ASM1_10:			CJNE		A, #'O', ASM1_11			; JUMP TO O'S SECOND CHARACTER ELSE CONTINUE 
					JMP			O2
ASM1_11:			CJNE		A, #'P', ASM1_12			; JUMP TO P'S SECOND CHARACTER ELSE CONTINUE 
					JMP			_P2
ASM1_12:			CJNE		A, #'R', ASM1_13			; JUMP TO R'S SECOND CHARACTER ELSE CONTINUE 
					JMP			_R2
ASM1_13:			CJNE		A, #'S', ASM1_14			; JUMP TO S'S SECOND CHARACTER ELSE CONTINUE 
					JMP			S2
ASM1_14:			CJNE		A, #'X', ASM				; JUMP TO X'S SECOND CHARACTER ELSE START AFRESH 
					JMP			X2
; ---------------------------------------------------------------------------------------------------------------------------------------

; ---------------------------------------------------------------------------------------------------------------------------------------
; >>>>====++++----<<<<>>>>====++++----<<<<>>>>====++++----<<<<>>>>====++++----<<<<>>>>====++++----<<<<>>>>====++++----<<<<
M_HEX_OUT_OF_RANGE:	LJMP		M_HEX						; THIS WAS CREATED DUE TO OUT OF RANGE ERROR
; >>>>====++++----<<<<>>>>====++++----<<<<>>>>====++++----<<<<>>>>====++++----<<<<>>>>====++++----<<<<>>>>====++++----<<<<
; ---------------------------------------------------------------------------------------------------------------------------------------

; ------------------------------------------ SECOND, THIRD & FOURTH CHARACTER KEY COMBINATION -----------------------------------------------------------

; FOR 'A' AS FIRST CHARACTER
A2:					CALL 		LCD_SHO
A2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, A2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', A2_2				; ACI
					CALL 		LCD_SHO
					MOV			A, #'I'
					MOV			33H, #0CEH					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

A2_2:				CJNE		A, #'D', A2_3				; CHECK MATCH FOR AD'S THIRD CHARACTER ELSE CONTINUE 
					CALL 		LCD_SHO
A2_2L1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, A2_2L1
					CLR			01H							; GET READY FOR NEXT KEY
				
					CJNE		A, #'C', A2_2L2				; ADC
					JMP			ADC_						; JUMP TO ADC OPERAND ELSE CONTINUE
A2_2L2:				CJNE		A, #'D', A2_2L3				; ADD
					JMP			ADD_						; JUMP TO ADD OPERAND ELSE CONTINUE
A2_2L3:				CJNE		A, #'I', A2_2L1				; ADI
					MOV			33H, #0C6H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

A2_3:				CJNE		A, #'N', A2_1				; CHECK MATCH FOR AN'S THIRD CHARACTER ELSE CONTINUE 
					CALL 		LCD_SHO
A2_3L1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, A2_3L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', A2_3L2				; ANA
					JMP			ANA_						; JUMP TO ANA OPERAND ELSE CONTINUE
A2_3L2:				CJNE		A, #'I', A2_3L1				; ANI 
					MOV			33H, #0E6H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

; FOR 'C' AS FIRST CHARACTER
C2:					CALL 		LCD_SHO
C2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, C2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', C2_2				; CALL
					D_STR
					DB			'ALL',0
					MOV			33H, #0CDH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

C2_2:				CJNE		A, #'C', C2_3				; CC 
					MOV			33H, #0DCH
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

C2_3:				CJNE		A, #'M', C2_4				; CM'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
C2_3L1:				CALL		KEYPAD_ID
					JNB			01H, C2_3L1					; GET READY FOR NEXT KEY
					CLR			01H

					CJNE		A, #'*', C2_3L2				; CM
					MOV			33H, #0FCH
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
C2_3L2:				CJNE		A, #'A', C2_3L3				; CMA
					MOV			33H, #2FH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

C2_3L3:				CJNE		A, #'C', C2_3L4				; CMC
					MOV			33H, #3FH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD OPCODE IN-TAKE
					AJMP		MAIN2

C2_3L4:				CJNE		A, #'P', C2_3L1
					JMP			CMP_						; JUMP TO CMP'S OPERAND CHARACTER ELSE CONTINUE 
; -------
C2_4:				CJNE		A, #'N', C2_5				; JUMP TO CN'S THIRD CHARACTER ELSE CONTINUE 
					CALL 		LCD_SHO
C2_4L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, C2_4L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', C2_4L2				; CNC
					MOV			33H, #0D4H
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
C2_4L2:				CJNE		A, #'Z', C2_4L1				; CNZ
					MOV			33H, #0C4H
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

C2_5:				CJNE		A, #'P', C2_6				; JUMP TO CP'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
C2_5L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, C2_5L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', C2_5L2				; CP
					MOV			33H, #0F4H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
C2_5L2:				CJNE		A, #'E', C2_5L3				; CPE
					MOV			33H, #0ECH
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

C2_5L3:				CJNE		A, #'I', C2_5L4				; CPI
					MOV			33H, #0FEH					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

C2_5L4:				CJNE		A, #'O', C2_5L1				; CPO
					MOV			33H, #0E4H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2


C2_6:				CJNE		A, #'Z', C2_7				; JUMP TO AN'S THIRD CHARACTER ELSE CONTINUE 
					MOV			33H, #0CCH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
C2_7:				AJMP		C2_1						; I PLACE THIS INSTRUCTION HERE DUE OUT OF RANGE ERROR

; FOR 'D' AS FIRST CHARACTER
D2:					CALL 		LCD_SHO
D2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, D2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', D2_2				; JUMP TO DA'S THIRD CHARACTER ELSE CONTINUE
					CALL		LCD_SHO
D2_1L1:				CALL 		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, D2_1L1					; GET READY FOR NEXT KEY
					CLR			01H

					CJNE		A, #'A', D2_1L2				; DAA
					MOV			33H, #27H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
D2_1L2:				CJNE		A, #'D', D2_1L1				; DAD
					JMP			DAD_						; JUMP TO DAD'S OPERAND CHARACTER ELSE CONTINUE 

D2_2:				CJNE		A, #'C', D2_3				; JUMP TO DC'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
D2_2L1:				CALL 		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, D2_2L1					; GET READY FOR NEXT KEY
					CLR			01H		
					
					CJNE		A, #'R', D2_2L2				; DCR
					JMP			DCR_						; JUMP TO DCR'S OPERAND CHARACTER ELSE CONTINUE 
D2_2L2:				CJNE		A, #'X', D2_2L1				; DCX
					JMP			DCX_						; JUMP TO DCX'S OPERAND CHARACTER ELSE CONTINUE 
													
D2_3:				CJNE		A, #'I', D2_1				; JUMP TO AN'S THIRD CHARACTER ELSE CONTINUE 
					MOV			33H, #0F3H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

; FOR 'I' AS FIRST CHARACTER
I2:					CALL 		LCD_SHO
					MOV			A, #'N'					    ; SHOW 'IN' AT ONCE AND WAIT FOR 'NEXT SR', CHARACTER 'R' OR 'X'
					CALL		LCD_SHO
I2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, I2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', I2_2				; IN
					MOV			33H, #0DBH					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2		
I2_2:				CJNE		A, #'R', I2_3
					JMP			INR_						; JUMP TO INR'S OPERAND CHARACTER ELSE CONTINUE 
I2_3:				CJNE		A, #'X', I2_1
					JMP			INX_						; JUMP TO INX'S OPERAND CHARACTER ELSE CONTINUE 

; FOR 'J' AS FIRST CHARACTER
J2:					CALL 		LCD_SHO
J2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, J2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', J2_2				; JC
					MOV			33H, #0DAH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

J2_2:				CJNE		A, #'M', J2_3				; JM'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
J2_2L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, J2_2L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', J2_2L2				; JM
					MOV			33H, #0FAH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2		
J2_2L2:				CJNE		A, #'P', J2_2L1				; JMP
					MOV			33H, #0C3H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2				

J2_3:				CJNE		A, #'N', J2_4				; JN'S THIRD CHARACTER ELSE CONTINUE 
					CALL 		LCD_SHO
J2_3L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, J2_3L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', J2_3L2				; JNC
					MOV			33H, #0D2H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
J2_3L2:				CJNE		A, #'Z', J2_3L1				; JNZ
					MOV			33H, #0C2H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2	 

J2_4:				CJNE		A, #'P', J2_5				; JP'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
J2_4L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, J2_4L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', J2_4L2				; JP
					MOV			33H, #0F2H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2		
J2_4L2:				CJNE		A, #'E', J2_4L3				; JPE
					MOV			33H, #0EAH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
J2_4L3:				CJNE		A, #'O', J2_4L1				; JPO
					MOV			33H, #0E2H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

J2_5:				CJNE		A, #'Z', J2_6				; JZ 
					MOV			33H, #0CAH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS					; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
J2_6:				AJMP		J2_1						; I PLACE THIS INSTRUCTION HERE DUE OUT OF RANGE ERROR

; FOR 'L' AS FIRST CHARACTER
L2:					CALL 		LCD_SHO
L2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, L2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'D', L2_2				; JUMP TO LDA'S FOURTH CHARACTER ELSE CONTINUE
					CALL		LCD_SHO
					MOV			A, #'A'						
					CALL		LCD_SHO
L2_1L1:				CALL		KEYPAD_ID					; ENSURE A KEY(4TH ALPHABET KEY) IS DEPRESSED
					JNB			01H, L2_1L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', L2_1L2				; LDA
					MOV			33H, #3AH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2		
L2_1L2:				CJNE		A, #'X', L2_1L1				; LDAX
					JMP			LDAX_						; JUMP TO LDAX'S OPERANDS ELSE CONTINUE

L2_2:				CJNE		A, #'H', L2_3				; LHLD 
					D_STR
					DB			'HLD',0
					MOV			33H, #2AH					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

L2_3:				CJNE		A, #'X', L2_1				; JUMP TO AN'S THIRD CHARACTER ELSE CONTINUE 
					CALL 		LCD_SHO
					MOV			A, #'I'
					JMP			LXI_						; JUMP TO LXI'S OPERANDS ELSE CONTINUE  

; FOR 'M' AS FIRST CHARACTER
M2:					CALL 		LCD_SHO
M2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, M2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'O', M2_2				; MOV
					CALL 		LCD_SHO
					MOV			A, #'V'
					JMP			MOV_						; JUMP TO MOV'S OPERAND CHARACTERS ELSE CONTINUE

M2_2:				CJNE		A, #'V', M2_1				; MVI
					CALL 		LCD_SHO
					MOV			A, #'I'
					JMP			MVI_						; JUMP TO MOV'S OPERAND CHARACTERS ELSE CONTINUE

; FOR 'O' AS FIRST CHARACTER
O2:					CALL 		LCD_SHO
O2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, O2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'R', O2_2				; JUMP TO OR'S THIRD CHARACTERS ELSE CONTINUE
					CALL 		LCD_SHO
O2_1L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, O2_1L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', O2_1L2				; ORA
					JMP			ORA_						; JUMP TO ORA'S OPERAND CHARACTERS ELSE CONTINUE
O2_1L2:				CJNE		A, #'I', O2_1L1				; ORI
					MOV			33H, #0F6H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

O2_2:				CJNE		A, #'U', O2_1				; OUT 
					CALL		LCD_SHO
					MOV			A, #'T'
					MOV			33H, #0D3H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

; FOR 'P' AS FIRST CHARACTER
_P2:				CALL 		LCD_SHO
_P2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, _P2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', _P2_2				; PCHL
					D_STR
					DB			'CHL',0
					MOV			33H, #0E9H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2
_P2_2:				CJNE		A, #'O', _P2_3				; POP
					CALL		LCD_SHO
					MOV			A, #'P'
					JMP			POP_						; JUMP TO POP'S OPERAND CHARACTERS ELSE CONTINUE 
_P2_3:				CJNE		A, #'U', _P2_1				; PUSH
					D_STR
					DB			'USH',0
					JMP			PUSH_						; JUMP TO PUSH'S OPERAND CHARACTERS ELSE CONTINUE 

; FOR 'R' AS FIRST CHARACTER
_R2:				CALL 		LCD_SHO
_R2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, _R2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'A', _R2_2				; JUMP TO RA'S THIRD CHARACTERS ELSE CONTINUE
					CALL		LCD_SHO
_R2_1L1:			CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, _R2_1L1
					CLR			01H		

					CJNE		A, #'L', _R2_1L2			; RAL
					MOV			33H, #17H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
_R2_1L2:			CJNE		A, #'R', _R2_1L1			; RAR
					MOV			33H, #1FH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_2:				CJNE		A, #'C', _R2_3				; RC 
					MOV			33H, #0D8H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_3:				CJNE		A, #'E', _R2_4				; RET 
					CALL		LCD_SHO
					MOV			A, #'T'
					MOV			33H, #0C9H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_4:				CJNE		A, #'I', _R2_5				; RIM
					CALL		LCD_SHO
					MOV			A, #'M'
					MOV			33H, #20H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_5:				CJNE		A, #'L', _R2_6				; RLC 
					CALL		LCD_SHO
					MOV			A, #'C'
					MOV			33H, #07H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_6:				CJNE		A, #'M', _R2_7				; RM 
					MOV			33H, #0F8H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_7:				CJNE		A, #'N', _R2_8				; JUMP TO RN'S THIRD CHARATER ELSE CONTINUE
					CALL		LCD_SHO
_R2_7L1:			CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, _R2_7L1
					CLR			01H		

					CJNE		A, #'C', _R2_7L2			; RNC
					MOV			33H, #0D0H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
_R2_7L2:			CJNE		A, #'Z', _R2_7L1			; RNZ
					MOV			33H, #0C0H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_8:				CJNE		A, #'P', _R2_9				; JUMP TO RP'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
_R2_8L1:			CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, _R2_8L1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', _R2_8L2			; RP
					MOV			33H, #0F0H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2		

_R2_8L2:			CJNE		A, #'E', _R2_8L3			; RPE
					MOV			33H, #0E8H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
 					AJMP		MAIN2

_R2_8L3:			CJNE		A, #'O', _R2_8L1			; RPO
					MOV			33H, #0E0H				    ; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
 					AJMP		MAIN2
; -------
_R2_9:				CJNE		A, #'R', _R2_10				; RRC 
					CALL		LCD_SHO
					MOV			A, #'C'
					MOV			33H, #0FH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_10:				CJNE		A, #'S', _R2_11				; RST
					CALL		LCD_SHO
					MOV			A, #'T'
					CALL		LCD_SHO						
					MOV			A, #' '
					CALL		LCD_SHO						; GET RST'S 4TH CHARACTER

_R2_10L1:			CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, _R2_10L1				
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'0', _R2_10L2			; RST 0
					MOV			33H, #0C7H					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L2:			CJNE		A, #'1', _R2_10L3			; RST 1
					MOV			33H, #0CFH					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L3:			CJNE		A, #'2', _R2_10L4			; RST 2
					MOV			33H, #0D7H					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L4:			CJNE		A, #'3', _R2_10L5			; RST 3
					MOV			33H, #0DFH					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L5:			CJNE		A, #'4', _R2_10L6			; RST 4
					MOV			33H, #0E7H					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L6:			CJNE		A, #'5', _R2_10L7			; RST 5
					MOV			33H, #0EFH					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L7:			CJNE		A, #'6', _R2_10L8			; RST 6
					MOV			33H, #0F7H					; LOAD ITS 8085 INST. SET
					SJMP		_R2_10L9
_R2_10L8:			CJNE		A, #'7', _R2_10L1			; RST 7
					MOV			33H, #0FFH					; LOAD ITS 8085 INST. SET
_R2_10L9:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; -------
_R2_11:				CJNE		A, #'Z', _R2_12				; JUMP TO AD'S THIRD CHARACTER ELSE CONTINUE 
					MOV			33H, #0C8H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
_R2_12:				AJMP		_R2_1						; I PLACED THIS INSTRUCTION DUE TO OUT OF RANGE ERROR

; FOR 'S' AS FIRST CHARACTER
S2:					CALL 		LCD_SHO
S2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, S2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'B', S2_2				; JUMP TO SB'S THIRD CHARACTER
					CALL		LCD_SHO
S2_1L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED 
					JNB			01H, S2_1L1
					CLR			01H							; GET READY FOR NEXT KEY
					CJNE		A, #'B', S2_1L2				; SBB
					JMP			SBB_						; JUMP TO SBB OPERAND CHARACTERS
S2_1L2:				CJNE		A, #'I', S2_1L1				; SBI					
					MOV			33H, #0DEH					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

S2_2:				CJNE		A, #'H', S2_3				; SHLD 
					D_STR
					DB			'HLD',0
					MOV			33H, #22H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2
S2_3:				CJNE		A, #'I', S2_4				; SIM 
					CALL		LCD_SHO
					MOV			A, #'M'
					MOV			33H, #30H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

S2_4:				CJNE		A, #'P', S2_5				; SPHL
					D_STR
					DB			'PHL',0
					MOV			33H, #0F9H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2

S2_5:				CJNE		A, #'T', S2_6				; JUMP TO ST'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
					
S2_5L1:				CALL		KEYPAD_ID
					JNB			01H, S2_5L1
					CLR			01H	
					CJNE		A, #'A', S2_5L2				; GET STA'S FOURTH CHARACTER
					CALL		LCD_SHO						
S2_5L1L1:			CALL		KEYPAD_ID					
					JNB			01H, S2_5L1L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'*', S2_5L1L2			; STA
					MOV			33H, #32H					; LOAD ITS 8085 INST. SET
					CALL		FLY_ADDRESS_SKIP			; CALL A SUBROUTINE THAT WOULD HANDLE ADDRESS OPERAND IN-TAKE
					AJMP		MAIN2		
S2_5L1L2:			CJNE		A, #'X', S2_5L1L1			; STAX
					JMP			STAX_						; JUMP TO STAX'S OPERAND CHARACTERS

S2_5L2:				CJNE		A, #'C', S2_5L1				; STC
					MOV			33H, #37H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

S2_6:				CJNE		A, #'U', S2_7				; JUMP TO SU'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
S2_6L1:				CALL		KEYPAD_ID					; ENSURE THAT A KEY IS PREESSED
					JNB			01H, S2_6L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', S2_6L2				; SUB
					JMP			SUB_						; JUMP TO SUB'S OPERAND CHARACTERS
S2_6L2:				CJNE		A, #'I', S2_6L1				; SUI					
					MOV			33H, #0D6H					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2
S2_7:				AJMP		S2_1						; I PLACED THIS INSTRUCTION DUE TO OUT OF RANGE ERROR

; FOR 'X' AS FIRST CHARACTER
X2:					CALL 		LCD_SHO
X2_1:				CALL		KEYPAD_ID					; ENSURE A KEY(2ND ALPHABET KEY) IS DEPRESSED
					JNB			01H, X2_1
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'C', X2_2				; XCHG ELSE CONTINUE
					D_STR
					DB			'CHG',0
					MOV			33H, #0EBH					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

X2_2:				CJNE		A, #'R', X2_3				; JUMP TO AD'S THIRD CHARACTER ELSE CONTINUE 
					CALL		LCD_SHO
X2_2L1:				CALL		KEYPAD_ID					; ENSURE A KEY(3RD ALPHABET KEY) IS DEPRESSED
					JNB			01H, X2_2L1
					CLR			01H							; GET READY FOR NEXT KEY
					
					CJNE		A, #'A', X2_2L2				; XRA
					JMP			XRA_						; JUMP TO XRA'S OPERAND CHARACTERS
X2_2L2:				CJNE		A, #'I', X2_2L1				; XRI
					MOV			33H, #0EEH					; LOAD ITS 8085 INST. SET
					CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					AJMP		MAIN2

X2_3:				CJNE		A, #'T', X2_1				; XTHL ELSE CONTINUE 
					D_STR
					DB			'THL',0
					MOV			33H, #0E3H					; LOAD ITS 8085 INST. SET
					CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; ---------------------------------------------------------------------------------------------------------------------------------------


; ------------------------------------------ OPERAND CHARACTER KEY COMBINATION -----------------------------------------------------------

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'ADC...'
ADC_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE 
					CALL		LCD_SHO
ADC_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, ADC_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', ADC_L2				; ADC A
					MOV			33H, #8FH					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L2:				CJNE		A, #'B', ADC_L3				; ADC B
					MOV			33H, #88H					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L3:				CJNE		A, #'C', ADC_L4				; ADC C
					MOV			33H, #89H					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L4:				CJNE		A, #'D', ADC_L5				; ADC D
					MOV			33H, #8AH					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L5:				CJNE		A, #'E', ADC_L6				; ADC E
					MOV			33H, #8BH					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L6:				CJNE		A, #'H', ADC_L7				; ADC H
					MOV			33H, #8CH					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L7:				CJNE		A, #'L', ADC_L8				; ADC L
					MOV			33H, #8DH					; LOAD ITS 8085 INST. SET
					SJMP		ADC_L9
ADC_L8:				CJNE		A, #'M', ADC_L1				; ADC M
					MOV			33H, #8EH					; LOAD ITS 8085 INST. SET

ADC_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

; ***** FOR 'ADD...'
ADD_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
ADD_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, ADD_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', ADD_L2				; ADD A
					MOV			33H, #87H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L2:				CJNE		A, #'B', ADD_L3				; ADD B
					MOV			33H, #80H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9	   
ADD_L3:				CJNE		A, #'C', ADD_L4				; ADD C
					MOV			33H, #81H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L4:				CJNE		A, #'D', ADD_L5				; ADD D
					MOV			33H, #82H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L5:				CJNE		A, #'E', ADD_L6				; ADD E
					MOV			33H, #83H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L6:				CJNE		A, #'H', ADD_L7				; ADD H
					MOV			33H, #84H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L7:				CJNE		A, #'L', ADD_L8				; ADD L
					MOV			33H, #85H					; LOAD ITS 8085 INST. SET
					SJMP		ADD_L9
ADD_L8:				CJNE		A, #'M', ADD_L1				; ADD M
					MOV			33H, #86H					; LOAD ITS 8085 INST. SET

ADD_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

; ***** FOR 'ANA...'
ANA_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
ANA_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, ANA_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', ANA_L2				; ANA A
					MOV			33H, #0A7H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L2:				CJNE		A, #'B', ANA_L3				; ANA B
					MOV			33H, #0A0H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L3:				CJNE		A, #'C', ANA_L4				; ANA C
					MOV			33H, #0A1H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L4:				CJNE		A, #'D', ANA_L5				; ANA D
					MOV			33H, #0A2H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L5:				CJNE		A, #'E', ANA_L6				; ANA E
					MOV			33H, #0A3H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L6:				CJNE		A, #'H', ANA_L7				; ANA H
					MOV			33H, #0A4H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L7:				CJNE		A, #'L', ANA_L8				; ANA L
					MOV			33H, #0A5H					; LOAD ITS 8085 INST. SET
					SJMP		ANA_L9
ANA_L8:				CJNE		A, #'M', ANA_L1				; ANA M
					MOV			33H, #0A6H					; LOAD ITS 8085 INST. SET

ANA_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2
; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'CMP...'
CMP_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
CMP_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, CMP_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', CMP_L2				; CMP A
					MOV			33H, #0BFH					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L2:				CJNE		A, #'B', CMP_L3				; CMP B
					MOV			33H, #0B8H					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L3:				CJNE		A, #'C', CMP_L4				; CMP C
					MOV			33H, #0B9H					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L4:				CJNE		A, #'D', CMP_L5				; CMP D
					MOV			33H, #0BAH					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L5:				CJNE		A, #'E', CMP_L6				; CMP E
					MOV			33H, #0BBH					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L6:				CJNE		A, #'H', CMP_L7				; CMP H
					MOV			33H, #0BCH					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L7:				CJNE		A, #'L', CMP_L8				; CMP L
					MOV			33H, #0BDH					; LOAD ITS 8085 INST. SET
					SJMP		CMP_L9
CMP_L8:				CJNE		A, #'M', CMP_L1				; CMP M
					MOV			33H, #0BEH					; LOAD ITS 8085 INST. SET

CMP_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'DAD...'
DAD_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
DAD_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, DAD_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', DAD_L2				; DAD B
					MOV			33H, #09H					; LOAD ITS 8085 INST. SET
					SJMP		DAD_L5
DAD_L2:				CJNE		A, #'D', DAD_L3				; DAD D
					MOV			33H, #19H					; LOAD ITS 8085 INST. SET
					SJMP		DAD_L5
DAD_L3:				CJNE		A, #'H', DAD_L4				; DAD H
					MOV			33H, #29H					; LOAD ITS 8085 INST. SET
					SJMP		DAD_L5
DAD_L4:				CJNE		A, #'S', DAD_L1				; DAD SP
					CALL		LCD_SHO
					MOV			A, #'P'
					MOV			33H, #39H					; LOAD ITS 8085 INST. SET

DAD_L5:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					AJMP		MAIN2

; ***** FOR 'DCR...'
DCR_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
DCR_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, DCR_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', DCR_L2				; DCR A
					MOV			33H, #3DH					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L2:				CJNE		A, #'B', DCR_L3				; DCR B
					MOV			33H, #05H					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L3:				CJNE		A, #'C', DCR_L4				; DCR C
					MOV			33H, #0DH					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L4:				CJNE		A, #'D', DCR_L5				; DCR D
					MOV			33H, #15H					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L5:				CJNE		A, #'E', DCR_L6				; DCR E
					MOV			33H, #1DH					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L6:				CJNE		A, #'H', DCR_L7				; DCR H
					MOV			33H, #25H					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L7:				CJNE		A, #'L', DCR_L8				; DCR L
					MOV			33H, #2DH					; LOAD ITS 8085 INST. SET
					SJMP		DCR_L9
DCR_L8:				CJNE		A, #'M', DCR_L1				; DCR M
					MOV			33H, #35H					; LOAD ITS 8085 INST. SET

DCR_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ***** FOR 'DCX...'
DCX_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
DCX_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, DCX_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', DCX_L2				; DCX B
					MOV			33H, #0BH					; LOAD ITS 8085 INST. SET
					SJMP		DCX_L5
DCX_L2:				CJNE		A, #'D', DCX_L3				; DCX D
					MOV			33H, #1BH					; LOAD ITS 8085 INST. SET
					SJMP		DCX_L5
DCX_L3:				CJNE		A, #'H', DCX_L4				; DCX H
					MOV			33H, #2BH					; LOAD ITS 8085 INST. SET
					SJMP		DCX_L5
DCX_L4:				CJNE		A, #'S', DCX_L1				; DCX SP
					CALL		LCD_SHO
					MOV			A, #'P'
					MOV			33H, #3BH					; LOAD ITS 8085 INST. SET

DCX_L5:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'INR...'
INR_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
INR_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, INR_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', INR_L2				; INR A
					MOV			33H, #3CH					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L2:				CJNE		A, #'B', INR_L3				; INR B
					MOV			33H, #04H					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L3:				CJNE		A, #'C', INR_L4				; INR C
					MOV			33H, #0CH					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L4:				CJNE		A, #'D', INR_L5				; INR D
					MOV			33H, #14H					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L5:				CJNE		A, #'E', INR_L6				; INR E
					MOV			33H, #1CH				 	; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L6:				CJNE		A, #'H', INR_L7				; INR H
					MOV			33H, #24H					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L7:				CJNE		A, #'L', INR_L8				; INR L
					MOV			33H, #2CH					; LOAD ITS 8085 INST. SET
					SJMP		INR_L9
INR_L8:				CJNE		A, #'M', INR_L1				; INR M
					MOV			33H, #34H					; LOAD ITS 8085 INST. SET

INR_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ***** FOR 'INX...'
INX_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
INX_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, INX_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', INX_L2				; INX B
					MOV			33H, #03H					; LOAD ITS 8085 INST. SET
					SJMP		INX_L5
INX_L2:				CJNE		A, #'D', INX_L3				; INX D
					MOV			33H, #13H					; LOAD ITS 8085 INST. SET
					SJMP		INX_L5
INX_L3:				CJNE		A, #'H', INX_L4				; INX H
					MOV			33H, #23H					; LOAD ITS 8085 INST. SET
					SJMP		INX_L5
INX_L4:				CJNE		A, #'S', INX_L1				; INX SP
					CALL		LCD_SHO
					MOV			A, #'P'
					MOV			33H, #33H					; LOAD ITS 8085 INST. SET

INX_L5:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'LDAX...'
LDAX_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
LDAX_L1:			CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, LDAX_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', LDAX_L2			; LDAX B
					MOV			33H, #0AH					; LOAD ITS 8085 INST. SET
					SJMP		LDAX_L3
LDAX_L2:			CJNE		A, #'D', LDAX_L1			; LDAX D
					MOV			33H, #1AH					; LOAD ITS 8085 INST. SET

LDAX_L3:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ***** FOR 'LXI...'
LXI_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
LXI_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, LXI_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', LXI_L2				; LXI B
					MOV			33H, #01H					; LOAD ITS 8085 INST. SET
					SJMP		LXI_L5
LXI_L2:				CJNE		A, #'D', LXI_L3				; LXI D
					MOV			33H, #11H					; LOAD ITS 8085 INST. SET
					SJMP		LXI_L5
LXI_L3:				CJNE		A, #'H', LXI_L4				; LXI H
					MOV			33H, #21H					; LOAD ITS 8085 INST. SET
					SJMP		LXI_L5
LXI_L4:				CJNE		A, #'S', LXI_L1				; LXI SP
					CALL		LCD_SHO						; LOAD ITS 8085 INST. SET
					MOV			A, #'P'
					MOV			33H, #31H					; LOAD ITS 8085 INST. SET

LXI_L5:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'MOV...'
MOV_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO

				; -- A -- ;
MOV_A:				CALL		KEYPAD_ID					; GET THE FIRST OPERAND 
					JNB			01H, MOV_A
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', MOV_B
					D_STR
					DB			'A, ',0						; MOV A,
															
MOV_AA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_AA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_AB				; MOV A, A
					MOV			33H, #7FH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT
MOV_AB:				CJNE		A, #'B', MOV_AC				; MOV A, B 
					MOV			33H, #78H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AC:				CJNE		A, #'C', MOV_AD				; MOV A, C
					MOV			33H, #79H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AD:				CJNE		A, #'D', MOV_AE				; MOV A, D
					MOV			33H, #7AH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AE:				CJNE		A, #'E', MOV_AH				; MOV A, E
					MOV			33H, #7BH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AH:				CJNE		A, #'H', MOV_AL				; MOV A, H
					MOV			33H, #7CH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AL:				CJNE		A, #'L', MOV_AM				; MOV A, L
					MOV			33H, #7DH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_AM:				CJNE		A, #'M', MOV_AA				; MOV A, M
					MOV			33H, #7EH					; LOAD ITS 8085 INST. SET

MOV_A_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- B -- ;
MOV_B:				CJNE		A, #'B', MOV_C
					D_STR
					DB			'B, ',0						; MOV B,

MOV_BA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_BA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_BB				; MOV B, A
					MOV			33H, #47H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT
MOV_BB:				CJNE		A, #'B', MOV_BC				; MOV B, B
					MOV			33H, #40H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BC:				CJNE		A, #'C', MOV_BD				; MOV B, C
					MOV			33H, #41H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BD:				CJNE		A, #'D', MOV_BE				; MOV B, D
					MOV			33H, #42H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BE:				CJNE		A, #'E', MOV_BH				; MOV B, E
					MOV			33H, #43H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BH:				CJNE		A, #'H', MOV_BL				; MOV B, H
					MOV			33H, #44H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BL:				CJNE		A, #'L', MOV_BM				; MOV B, L
					MOV			33H, #45H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_A_EXIT										
MOV_BM:				CJNE		A, #'M', MOV_BA				; MOV B, M
					MOV			33H, #46H					; LOAD ITS 8085 INST. SET

MOV_B_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- C -- ;
MOV_C:				CJNE		A, #'C', MOV_D
					D_STR
					DB			'C, ',0						; MOV C,

MOV_CA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_CA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_CB				; MOV C, A
					MOV			33H, #4FH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT
MOV_CB:				CJNE		A, #'B', MOV_CC				; MOV C, B
					MOV			33H, #48H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CC:				CJNE		A, #'C', MOV_CD				; MOV C, C
					MOV			33H, #49H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CD:				CJNE		A, #'D', MOV_CE				; MOV C, D
					MOV			33H, #4AH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CE:				CJNE		A, #'E', MOV_CH				; MOV C, E
					MOV			33H, #4BH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CH:				CJNE		A, #'H', MOV_CL				; MOV C, H
					MOV			33H, #4CH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CL:				CJNE		A, #'L', MOV_CM				; MOV C, L
					MOV			33H, #4DH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_C_EXIT										
MOV_CM:				CJNE		A, #'M', MOV_CA				; MOV C, M
					MOV			33H, #4EH					; LOAD ITS 8085 INST. SET

MOV_C_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- D -- ;
MOV_D:				CJNE		A, #'D', MOV_E
					D_STR
					DB			'D, ',0						; MOV D, 

MOV_DA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_DA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_DB				; MOV D, A
					MOV			33H, #57H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT
MOV_DB:				CJNE		A, #'B', MOV_DC				; MOV D, B
					MOV			33H, #50H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DC:				CJNE		A, #'C', MOV_DD				; MOV D, C
					MOV			33H, #51H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DD:				CJNE		A, #'D', MOV_DE				; MOV D, D
					MOV			33H, #52H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DE:				CJNE		A, #'E', MOV_DH				; MOV D, E
					MOV			33H, #53H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DH:				CJNE		A, #'H', MOV_DL				; MOV D, H
					MOV			33H, #54H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DL:				CJNE		A, #'L', MOV_DM				; MOV D, L
					MOV			33H, #55H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_D_EXIT										
MOV_DM:				CJNE		A, #'M', MOV_DA				; MOV D, M
					MOV			33H, #56H					; LOAD ITS 8085 INST. SET

MOV_D_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- E -- ;
MOV_E:				CJNE		A, #'E', MOV_H
					D_STR
					DB			'E, ',0						; MOV E, 

MOV_EA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_EA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_EB				; MOV E, A
					MOV			33H, #5FH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT
MOV_EB:				CJNE		A, #'B', MOV_EC				; MOV E, B
					MOV			33H, #58H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_EC:				CJNE		A, #'C', MOV_ED				; MOV E, C
					MOV			33H, #59H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_ED:				CJNE		A, #'D', MOV_EE				; MOV E, D
					MOV			33H, #5AH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_EE:				CJNE		A, #'E', MOV_EH				; MOV E, E
					MOV			33H, #5BH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_EH:				CJNE		A, #'H', MOV_EL				; MOV E, H
					MOV			33H, #5CH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_EL:				CJNE		A, #'L', MOV_EM				; MOV E, L
					MOV			33H, #5DH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_E_EXIT										
MOV_EM:				CJNE		A, #'M', MOV_EA				; MOV E, M
					MOV			33H, #5EH					; LOAD ITS 8085 INST. SET

MOV_E_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- H -- ;
MOV_H:				CJNE		A, #'H', MOV_L
					D_STR
					DB			'H, ',0						; MOV H, 

MOV_HA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_HA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_HB				; MOV H, A
					MOV			33H, #67H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT
MOV_HB:				CJNE		A, #'B', MOV_HC				; MOV H, B
					MOV			33H, #60H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HC:				CJNE		A, #'C', MOV_HD				; MOV H, C
					MOV			33H, #61H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HD:				CJNE		A, #'D', MOV_HE				; MOV H, D
					MOV			33H, #62H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HE:				CJNE		A, #'E', MOV_HH				; MOV H, E
					MOV			33H, #63H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HH:				CJNE		A, #'H', MOV_HL				; MOV H, H
					MOV			33H, #64H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HL:				CJNE		A, #'L', MOV_HM				; MOV H, L
					MOV			33H, #65H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_H_EXIT										
MOV_HM:				CJNE		A, #'M', MOV_HA				; MOV H, M
					MOV			33H, #66H					; LOAD ITS 8085 INST. SET

MOV_H_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- L -- ;
MOV_L:				CJNE		A, #'L', MOV_M
					D_STR
					DB			'L, ',0						; MOV L, 

MOV_LA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND
					JNB			01H, MOV_LA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_LB				; MOV L, A
					MOV			33H, #6FH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT
MOV_LB:				CJNE		A, #'B', MOV_LC				; MOV L, B
					MOV			33H, #68H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LC:				CJNE		A, #'C', MOV_LD				; MOV L, C
					MOV			33H, #69H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LD:				CJNE		A, #'D', MOV_LE				; MOV L, D
					MOV			33H, #6AH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LE:				CJNE		A, #'E', MOV_LH				; MOV L, E
					MOV			33H, #6BH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LH:				CJNE		A, #'H', MOV_LL				; MOV L, H
					MOV			33H, #6CH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LL:				CJNE		A, #'L', MOV_LM				; MOV L, L
					MOV			33H, #6DH					; LOAD ITS 8085 INST. SET
					SJMP		MOV_L_EXIT										
MOV_LM:				CJNE		A, #'M', MOV_LA				; MOV L, M
					MOV			33H, #6EH					; LOAD ITS 8085 INST. SET

MOV_L_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

				; -- M -- ;
MOV_M:				CJNE		A, #'M', MOV_A_EXTRA		; I PLACED THIS INSTRUCTION DUE TO OUT OF RANGE ERROR
					D_STR										
					DB			'M, ',0						; MOV M, 

MOV_MA:				CALL		KEYPAD_ID					; GET THE SECOND OPERAND 
					JNB			01H, MOV_MA
					CLR			01H							; GET READY FOR THE NEXT KEY
					
					CJNE		A, #'A', MOV_MB				; MOV M, A
					MOV			33H, #77H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT
MOV_MB:				CJNE		A, #'B', MOV_MC				; MOV M, B
					MOV			33H, #70H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT										
MOV_MC:				CJNE		A, #'C', MOV_MD				; MOV M, C
					MOV			33H, #71H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT										
MOV_MD:				CJNE		A, #'D', MOV_ME				; MOV M, D
					MOV			33H, #72H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT										
MOV_ME:				CJNE		A, #'E', MOV_MH				; MOV M, E
					MOV			33H, #73H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT										
MOV_MH:				CJNE		A, #'H', MOV_ML				; MOV M, H
					MOV			33H, #74H					; LOAD ITS 8085 INST. SET
					SJMP		MOV_M_EXIT										
MOV_ML:				CJNE		A, #'L', MOV_MA				; MOV M, L
					MOV			33H, #75H					; LOAD ITS 8085 INST. SET
															; NOTICE THAT THERE IS NO INSTRUCTION LIKE 'MOV M, M'
MOV_M_EXIT:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

MOV_A_EXTRA:		AJMP		MOV_A						; THIS INST. WAS TO THE EFFECT OF OUT OF RANGE ERROR

; ***** FOR 'MVI...'
MVI_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
MVI_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, MVI_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', MVI_L2				; MVI A
					MOV			33H, #3EH					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L2:				CJNE		A, #'B', MVI_L3				; MVI B
					MOV			33H, #06H					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L3:				CJNE		A, #'C', MVI_L4				; MVI C
					MOV			33H, #0EH					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L4:				CJNE		A, #'D', MVI_L5				; MVI D
					MOV			33H, #16H					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L5:				CJNE		A, #'E', MVI_L6				; MVI E
					MOV			33H, #1EH					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L6:				CJNE		A, #'H', MVI_L7				; MVI H
					MOV			33H, #26H					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L7:				CJNE		A, #'L', MVI_L8				; MVI L
					MOV			33H, #2EH					; LOAD ITS 8085 INST. SET
					SJMP		MVI_L9
MVI_L8:				CJNE		A, #'M', MVI_L1				; MVI M
					MOV			33H, #36H					; LOAD ITS 8085 INST. SET

MVI_L9:				CALL		FLY_DATA					; CALL A SUBROUTINE THAT WOULD HANDLE DATA OPERAND IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'ORA...'
ORA_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
ORA_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, ORA_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', ORA_L2				; ORA A
					MOV			33H, #0B7H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L2:				CJNE		A, #'B', ORA_L3				; ORA B
					MOV			33H, #0B0H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L3:				CJNE		A, #'C', ORA_L4				; ORA C
					MOV			33H, #0B1H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L4:				CJNE		A, #'D', ORA_L5				; ORA D
					MOV			33H, #0B2H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L5:				CJNE		A, #'E', ORA_L6				; ORA E
					MOV			33H, #0B3H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L6:				CJNE		A, #'H', ORA_L7				; ORA H
					MOV			33H, #0B4H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L7:				CJNE		A, #'L', ORA_L8				; ORA L
					MOV			33H, #0B5H					; LOAD ITS 8085 INST. SET
					SJMP		ORA_L9
ORA_L8:				CJNE		A, #'M', ORA_L1				; ORA M
					MOV			33H, #0B6H					; LOAD ITS 8085 INST. SET

ORA_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'POP...'
POP_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
POP_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, POP_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', POP_L2				; POP B
					MOV			33H, #0C1H					; LOAD ITS 8085 INST. SET
					SJMP		POP_L5
POP_L2:				CJNE		A, #'D', POP_L3				; POP D
					MOV			33H, #0D1H					; LOAD ITS 8085 INST. SET
					SJMP		POP_L5
POP_L3:				CJNE		A, #'H', POP_L4				; POP H
					MOV			33H, #0E1H					; LOAD ITS 8085 INST. SET
					SJMP		POP_L5
POP_L4:				CJNE		A, #'P', POP_L1				; POP PSW
					D_STR
					DB			'PSW',0
					MOV			33H, #0F1H					; LOAD ITS 8085 INST. SET

POP_L5:				CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ***** FOR 'PUSH...'
PUSH_:				MOV			A, #' '					    ; GIVE SPACE
					CALL		LCD_SHO
PUSH_L1:			CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, PUSH_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', PUSH_L2			; PUSH B
					MOV			33H, #0C5H					; LOAD ITS 8085 INST. SET
					SJMP		PUSH_L5
PUSH_L2:			CJNE		A, #'D', PUSH_L3			; PUSH D
					MOV			33H, #0D5H					; LOAD ITS 8085 INST. SET
					SJMP		PUSH_L5
PUSH_L3:			CJNE		A, #'H', PUSH_L4			; PUSH H
					MOV			33H, #0E5H					; LOAD ITS 8085 INST. SET
					SJMP		PUSH_L5
PUSH_L4:			CJNE		A, #'P', PUSH_L1			; PUSH PSW
					D_STR
					DB			'PSW',0
					MOV			33H, #0F5H					; LOAD ITS 8085 INST. SET

PUSH_L5:			CALL		FLY_OPCODE_SKIP				; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'SBB...'
SBB_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
SBB_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, SBB_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', SBB_L2				; SBB A
					MOV			33H, #9FH					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L2:				CJNE		A, #'B', SBB_L3				; SBB B
					MOV			33H, #98H					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L3:				CJNE		A, #'C', SBB_L4				; SBB C
					MOV			33H, #99H					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L4:				CJNE		A, #'D', SBB_L5				; SBB D
					MOV			33H, #9AH					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L5:				CJNE		A, #'E', SBB_L6				; SBB E
					MOV			33H, #9BH					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L6:				CJNE		A, #'H', SBB_L7				; SBB H
					MOV			33H, #9CH					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L7:				CJNE		A, #'L', SBB_L8				; SBB L
					MOV			33H, #9DH					; LOAD ITS 8085 INST. SET
					SJMP		SBB_L9
SBB_L8:				CJNE		A, #'M', SBB_L1				; SBB M
					MOV			33H, #9EH					; LOAD ITS 8085 INST. SET

SBB_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ***** FOR 'SUB...'
SUB_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
SUB_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, SUB_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', SUB_L2				; SUB A
					MOV			33H, #97H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L2:				CJNE		A, #'B', SUB_L3				; SUB B
					MOV			33H, #90H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L3:				CJNE		A, #'C', SUB_L4				; SUB C
					MOV			33H, #91H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L4:				CJNE		A, #'D', SUB_L5				; SUB D
					MOV			33H, #92H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L5:				CJNE		A, #'E', SUB_L6				; SUB E
					MOV			33H, #93H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L6:				CJNE		A, #'H', SUB_L7				; SUB H
					MOV			33H, #94H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L7:				CJNE		A, #'L', SUB_L8				; SUB L
					MOV			33H, #95H					; LOAD ITS 8085 INST. SET
					SJMP		SUB_L9
SUB_L8:				CJNE		A, #'M', SUB_L1				; SUB M
					MOV			33H, #96H					; LOAD ITS 8085 INST. SET

SUB_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ***** FOR 'STAX...'
STAX_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
STAX_L1:			CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, STAX_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'B', STAX_L2			; STAX B
					MOV			33H, #02H					; LOAD ITS 8085 INST. SET
					SJMP		STAX_L3
STAX_L2:			CJNE		A, #'D', STAX_L1			; STAX D
					MOV			33H, #12H					; LOAD ITS 8085 INST. SET

STAX_L3:			CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; ***** FOR 'XRA...'
XRA_:				CALL 		LCD_SHO
					MOV			A, #' '						; GIVE SPACE
					CALL		LCD_SHO
XRA_L1:				CALL		KEYPAD_ID					; ENSURE A KEY (OPERAND ALPHABET) IS DEPRESSED
					JNB			01H, XRA_L1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'A', XRA_L2				; XRA A
					MOV			33H, #0AFH					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L2:				CJNE		A, #'B', XRA_L3				; XRA B
					MOV			33H, #0A8H					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L3:				CJNE		A, #'C', XRA_L4				; XRA C
					MOV			33H, #0A9H					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L4:				CJNE		A, #'D', XRA_L5				; XRA D
					MOV			33H, #0AAH					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L5:				CJNE		A, #'E', XRA_L6				; XRA E
					MOV			33H, #0ABH					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L6:				CJNE		A, #'H', XRA_L7				; XRA H
					MOV			33H, #0ACH					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L7:				CJNE		A, #'L', XRA_L8				; XRA L
					MOV			33H, #0ADH					; LOAD ITS 8085 INST. SET
					SJMP		XRA_L9
XRA_L8:				CJNE		A, #'M', XRA_L1				; XRA M
					MOV			33H, #0AEH					; LOAD ITS 8085 INST. SET

XRA_L9:				CALL		FLY_OPCODE					; CALL A SUBROUTINE THAT WOULD HANDLE OPCODE IN-TAKE
					LJMP		MAIN2

; ------------------------------------------ END OF CHARACTER KEY COMBINATION ----------------------------------------------------------

; ================================================ INTERRUPT SUBROUTINES (ISRs) ========================================================
SECOND_FUNCTION:
					LCALL 		DELAY_500mS					; DELAY_500mS = 500ms
					LCALL 		KEYPAD_ID					; CALL THE KEYPAD TO SUPPLY THE ASCII OF THE KEY DEPRESSED
					DJNZ		30H, SECOND_FUNCTION		; MAKE THE SECOND FUNCTION ACTIVE FOR ABOUT 2 SECONDS
					JNB			01H, EXIT_SECOND_FUNCTION	; IF NO KEY IS DEPRESSED AFTER 2 SECONDS, EXIT ELSE CONTINUE
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'M', SF_1
					LCALL		SUB_MEM						; CALL SUBTITUTE MEMORY OSR
					SJMP		EXIT_SECOND_FUNCTION	

SF_1:				CJNE		A, #'X', SF_2
					LCALL		EXE							; CALL EXECUTE OSR
					SJMP		EXIT_SECOND_FUNCTION
												
SF_2:				CJNE		A, #'N', SF_3
					LCALL		CANCEL						; CALL CANCEL OSR
					MOV			SP, #57H					; INITIALIZATION OF THE TOP OF THE STACK(40 BYTES OF MEM. ARE AVAILABLE ON THIS INITIALIZATION)
					JMP			MAIN2						; START AFRESH

;SF_3:				CJNE		A, #'C', SF_4 
;					LCALL		CPLT						; CALL CPLT (CODE OR PROGRAMMING LANGUAGE TYPE) OSR
;					SJMP		EXIT_SECOND_FUNCTION
					 
SF_3:				CJNE		A, #'B', SF_4 
					LCALL		STEP						; CALL STEP-BY-STEP EXECUTION OSR
					SJMP		EXIT_SECOND_FUNCTION

SF_4:				CJNE		A, #'Z', SF_5 
					LCALL		EXAM_REG					; CALL EXAM_REG SR
					SJMP		EXIT_SECOND_FUNCTION

SF_5:				CJNE		A, #'V', SF_6 
					LCALL		V_HEX						; CALL V_HEX (VIEW HEXCODE) OSR
					SJMP		EXIT_SECOND_FUNCTION

SF_6:				CJNE		A, #'*', EXIT_SECOND_FUNCTION 
					LCALL		E_N_D						; CALL E_N_D (END PROGRAM) OSR
					
EXIT_SECOND_FUNCTION:
				   	RETI

; ================================================ ORDINARY SUBROUTINES (OSRs) ==========================================================

; ---------------------------------------------------------------------------------------------------------------------------------------
ADDRESS_DISPLAY_CONTROL:
; THIS SR IS USED BY FLY_OPCODE & FLY_OPERAND (ie DATA TYPE & ADDRESS TYPE) TO CONTROL THE ADDRESS DISPLAY IN LINE 1
; WHENEVER ENTRY IN LINE 2 IS COMPLETE AND NEXT IS PRESSED.
; ALSO IT IS USED BY V_HEX AND CANCEL SR TO CONTROL THE ADDRESS DISPLAY IN LINE 1
; THE INPUT MEMORY LOCATIONS TO THIS SUBROUTINE ARE 3AH & 39H

; IT FIRST CLEARS THE SCREEN OF THE LCD BEFORE WRITING INTO ITS LINE 1 ONLY. ALSO INCLUDE ':' AFTER THE ADDRESS

				CLR_LCD

				; MOST SIGNIFICANT BYTE (MSB)
				MOV			36H, 3AH				; PLACE THE HOB OF THE CURRENT ADDRESS INTO THE INPUT MEMORY LOC. (36H) OF H2A SR
				CALL		HEX_2_ASCII

				MOV			A, #80H					; LOAD A COMMAND TO DISPLAY THE CONTENT OF 38H & 37H ON LINE 1, POSITION 1 & 2
				CALL		LCD_CMD

				MOV			A, 38H					; 1ST NIBBLE DISPLAYED IN HEX IN POSITION 1
				CALL		LCD_SHO

				MOV			A, 37H					; 2ND NIBBLE DISPLAYED IN HEX IN POSITION 2
				CALL		LCD_SHO

				; LEAST SIGNIFICANT BYTE (LSB)
				MOV			36H, 39H				; PLACE THE HOB OF THE CURRENT ADDRESS INTO THE INPUT MEMORY LOC. (36H) OF H2A SR
				CALL		HEX_2_ASCII

				MOV			A, 38H					; 3RD NIBBLE DISPLAYED IN HEX IN POSITION 3
				CALL		LCD_SHO

				MOV			A, 37H					; 4TH (LAST) NIBBLE DISPLAYED IN HEX IN POSITION 4
				CALL		LCD_SHO


				MOV			A, #':'					; DISPLAY ':' PROBABLY ON LINE 1, POSITION 5 (SINCE FOUR DISPLAYS HAS BEEN CARRIED OUT)
				CALL		LCD_SHO

				RET

; ---------------------------------------------------------------------------------------------------------------------------------------
; THIS SUBROUTINE CONVERTS A GIVEN ASCII CHARACTER INTO ITS EQUIVALENT HGEXADECIMAL NUMBER USING 8051 INSTRUCTION SETS
; SOME ADDITIONAL CODE HERE ARE TO ENSURE PROTECTION SINCE THIS SR IS TO BE USED WERE A-Z APHABET KEYS ARE AVAILABLE TO BE DEPRESSED

; REGISTER DEFINITION:
; OPERATING REGISTER = A

; BI			BIT		04H					; BYTE INDICATOR (INDICATES WHEN AN OPERAND IS A 2 BYTE(4 NIBBLES) OR 1 BYTE (2NIBBLES) )


; ****REMEMBER TO SAVE REGS & FLAGS STILL RELEVANT TO THE CALLER PROGRAM TO AVOID DATA LOSS****

ASCII_2_HEX:	
				CJNE	A, #30H, A2H_1	; THE CONTENT OF 'A' MUST SATISFY THE FOLLOWING INEQUALITY: 30H =< A =< 46H
				CLR		C				; ENSURE IT PASSES TO THE NEXT INSTRUCTION

A2H_1:			JC		EXIT_A2H
				SUBB	A, #30H 		; SUBTRACT 30H FROM A REGISTER
				CJNE	A, #0AH, A2H_2
				CLR		C 				; ENSURE IT PASSES TO THE NEXT INSTRUCTION

A2H_2:			JC		A2H_4
				SUBB	A, #07H			; SUBTRACT 07H FROM 'A' REGISTER
				CJNE	A, #0FH, A2H_3	; CHECK IF THE RESULT OF THE SUBTRACTION IS GREATER THAN 0FH; IF SO EXIT THE SR ELSE CONTINUE
				SETB	C				; ENSURE IT PASSES TO THE NEXT INSTRUCTION

A2H_3:			JNC		EXIT_A2H		
; ELOO U MAY PUT UR FLAG FOR SUB MEM ASCII_2_HEX SR CALL HERE(NOTE SUCH FLAG MUST BE CLEAR AT THE SUB MEM SR ON RETURN IMMEDIATELY)
; EXPECTED FLAG INSTRUCTION: JB		SubMem'sAscii2hexFlag, EXIT_A2H

; THE TEST IS COMPLETED. THE INEQUQLITY: 30H =< A =< 46H HAS BEEN SATISFIED AND CONVERSION HAS TAKEN PLACE!!!

A2H_4:			SETB	02H				; THE FLAG, 02H BEEN SET INDICATES THAT THE KEY PRESSED IS BETWEEN 0 - F IN HEX
				CLR		C				; ENSURE THAT THE SUBTRCTION IS DONE WITHOUT BORROW(ie THE CARRY FLAG)

; MARRIAGE BEGINS
				JNB		04H, A2H_7		; MEM BIT, 04H = 1 MEANS 2 BYTES(4 NIBBLES) & 04H = 0 MEANS 1 BYTE (2 NIBBLES)
				JB		06H, A2H_5		; HAS THE MARRIAGE OF HIGH ORDER BYTE COMPLETED? FOR NO, 06H = 1; FOR YES, 06H = 0
				SJMP	A2H_7			; JMUP FOR THE LOWER BYTE OF ADDRESS

; FOR HIGHER ORDER BYTE OF AN ADDRESS
A2H_5:			CPL		05H				; CONTROLS THE NIBBLE MARRIAGE INTO A BYTE
				JB		05H, A2H_6
				ORL		A, 35H			; MARRY MSB(1ST NIBBLE IN MEM LOC. 34H) AND THE LSB(2ND NIBBLE IN 'A') INTO A BYTE DATA OR ADDRESS
				MOV		35H, A			; SAVE THE FINAL RESULT IN MEM LOC. 35H 
				CLR		06H				; CLEARS ON MARRIAGE COMPLETION FOR HIGH ORDER BYTE
				SJMP	EXIT_A2H

A2H_6:			RL		A				; SWAP MSB AND LSB
				RL		A
				RL		A
				RL		A
				MOV		35H, A			; SAVE THE CURRENT RESULT IN MEM LOC. 35H

				SJMP 	EXIT_A2H

; FOR DATA OR LOWER ORDER BYTE OF AN ADDRESS
A2H_7:			CPL		05H				; CONTROLS THE NIBBLE MARRIAGE INTO A BYTE
				JB		05H, A2H_8
				ORL		A, 34H			; MARRY MSB(1ST NIBBLE IN MEM LOC. 34H) AND THE LSB(2ND NIBBLE IN 'A') INTO A BYTE DATA OR ADDRESS
				MOV		34H, A			; SAVE THE FINAL RESULT IN MEM LOC. 34H 
				SJMP	EXIT_A2H

A2H_8:			RL		A				; SWAP MSB AND LSB
				RL		A
				RL		A
				RL		A
				MOV		34H, A			; SAVE THE CURRENT RESULT IN MEM LOC. 34H

EXIT_A2H:
				RET						; RETURN TO THE CALLER PROGRAM

; TESTED: QC PASSED SYNTAXICALLY

; ---------------------------------------------------------------------------------------------------------------------------------------
; CANCEL (<===)
; THIS IS THE SR THAT IS CALLED BY THE USER WHEN HE/SHE MAKES A MISTAKE
; THE SR CANCELS ALL THE CHARACTERS IN THE CURRENT LINE (EITHER LINE 1 OR 2) OF THE LCD

CANCEL:				; RESTORE IN THE ADDRESS DISPLAY CONTROL MEM LOC. THE CURRENT ADDRESS ALREADY SAVED IN THE PAGE MEMORY 
					CLR			05H							; REFRESH THE BYTE MARRIAGE FLAG. IT HELPS THE CANCEL SR

					MOV			3AH, 43H					; (HOB)
					MOV			39H, 42H					; (LOB)
				
					CALL		ADDRESS_DISPLAY_CONTROL
					; see if any other memory location for those it has affected 

					; THE STACK POINTER IS ALWAYS RESET WHEN THE SUBROUTINE RETURNS
					; THE SUBROUTINE TAKE CARE OF WHEHTER THE USER IS USING THE MHEX OR THE ASM TO PROGRAM
EXIT_CANCEL:
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
DELAY_500mS:
; THIS SUBROUTINE PROVIDES A DELAY OF 500ms TO ENSURE THAT THE SECOND FUNCTION IS ON FOR AT LEAST 2sec (ie 4 X 500ms)
					MOV		50H, #19H						; MOVE #19H (25DEC) INTO MEM LOC. 50H FOR DELAY (25 x 20mS = 500mS)
					; 20mS DELAY
DLY_500mS_1:		MOV		51H, #3AH						; MOVE #3AH & #0ABH INTO MEM LOCATIONS (51H & 52H) THAT SERVE 
DLY_500mS_2:		MOV		52H, #0ABH						; AS COUNTER FOR THIS PARTICULAR DELAY SUBROUTINE
					DJNZ	52H, $							; STAY HERE TILL THE CONTENT OF THE MEMORY LOCATION (52H) IS ZERO
					DJNZ	51H, DLY_500mS_2				; STAY HERE TILL THE CONTENT OF THE MEMORY LOCATION (51H) IS ZERO
					;	 --- END
					DJNZ	50H, DLY_500mS_1				; STAY HERE TILL THE CONTENT OF THE MEMORY LOCATION (50H) IS ZERO

					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
; THIS SUBROUTINE PROVIDES A DELAY OF 2S TO ENSURE THAT THE MESSAGE DISPLAYED IN GO_TO OSR IS SEEN BY THE USER
DELAY_2S:			MOV		50H, #64H						; MOVE #64H (100DEC) INTO MEM LOC. 50H FOR DELAY (100 x 20mS = 2S)
					; 20mS DELAY
DLY_2S_1:			MOV		51H, #3DH						; MOVE #0FFH INTO MEM LOCATIONS (52H & 52H) THAT SERVE 
DLY_2S_2:			MOV		52H, #0A2H						; AS COUNTER FOR THIS PARTICULAR DELAY SUBROUTINE
					DJNZ	52H, $							; STAY HERE TILL THE CONTENT OF THE MEMORY LOCATION (52H) IS ZERO
					DJNZ	51H, DLY_2S_2					; STAY HERE TILL THE CONTENT OF THE MEMORY LOCATION (51H) IS ZERO
					; --- END
					DJNZ	50H, DLY_2S_1					; STAY HERE TILL THE CONTENT OF THE MEMORY LOCATION (50H) IS ZERO
				
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
DISP_CHAR:
        			POP     	DPH
        			POP     	DPL
PRINT_TEXT:
        			CLR     	A
        			MOVC    	A, @A+DPTR
       				CJNE    	A, #00H, LOOP
       				SJMP    	RETURN
LOOP:  				LCALL  		LCD_SHO
        			INC     	DPTR
        			LJMP    	PRINT_TEXT
RETURN: 			MOV     	A, #01H
        			JMP     	@A+DPTR

; ---------------------------------------------------------------------------------------------------------------------------------------
; E_N_D (END OF PROGRAM)
; THIS SR IS THE SUBBROUTINE THAT IS CALLED BY THE USER AT THE END OF ANY PROGRAM WRITING
; REMEMBER TO DECREMENT THE CURRENT ADDRESS MEMORY LOC BEFORE SAVING IT INSIDE END MEMORY LOCATION

; *** REMEMBER THE S1 - S4 AND L1 - L4

E_N_D:
					CLR_LCD
					D_STR									; DISPLAY THE FOLLOWING STRINGS ON LINE ONE (SINCE LCD DDRAM ADDRESS RESETS WHEN CLEARED)
					DB			' Please Wait... ',0

					PUSH		DPH							; SAVE THIER CONTENTS
					PUSH		DPL
					
					MOV			R1, #43H					; STARTING ADDRESS OF THE RESERVED AREA FOR ...
					MOV			R0, #42H					; RESULTS OF THE EXAMINED 8085'S REG. = PAGE ADDRESS

; ------------------------------------
					MOV			DPH, 43H				   	; THE PAGE ADDRESS CONTAINS THE BEGINNING OF THE MEMORY SPACE WHERE THE CONTENT...
					MOV			DPL, 42H				   	; OF EXAMINED 8085'S REGISTERS ARE SAVED. 1 OF (2 BYTE X 7)
															; FOR REGISTER A

					INC			DPTR						; THE ADDRESS OF THE RESERVED AREA FOR THE EXAMINED REGISTERS. 2 OF (2 BYTE X 7)
					MOV			45H, DPH				   	; FOR REGISTER B
					MOV			44H, DPL				   	

					INC			DPTR						; THE ADDRESS OF THE RESERVED AREA FOR THE EXAMINED REGISTERS. 3 OF (2 BYTE X 7)
					MOV			47H, DPH				   	; FOR REGISTER C
					MOV			46H, DPL				   	

					INC			DPTR						; THE ADDRESS OF THE RESERVED AREA FOR THE EXAMINED REGISTERS. 4 OF (2 BYTE X 7)
					MOV			49H, DPH				   	; FOR REGISTER D
					MOV			48H, DPL				   	

					INC			DPTR						; THE ADDRESS OF THE RESERVED AREA FOR THE EXAMINED REGISTERS. 5 OF (2 BYTE X 7)
					MOV			4BH, DPH				   	; FOR REGISTER E
					MOV			4AH, DPL				   	

					INC			DPTR						; THE ADDRESS OF THE RESERVED AREA FOR THE EXAMINED REGISTERS. 6 OF (2 BYTE X 7)
					MOV			4DH, DPH				   	; FOR REGISTER H
					MOV			4CH, DPL				   	

					INC			DPTR						; THE ADDRESS OF THE RESERVED AREA FOR THE EXAMINED REGISTERS. 7 OF (2 BYTE X 7)
					MOV			4FH, DPH				   	; FOR REGISTER L
					MOV			4EH, DPL				   	


; ------------------------------------
;					MOV			A, #7FH						; SAVE THE HEXCODE (8085 INST. SET) OF THE INSTRUCTION 'MOV	A, A' 
					CALL		END_LOADER					; NOTICE THAT IT IS NOT NECESSARY FOR uP TO CARRY OUT THE ABOVE INSTRUCTION

					MOV			A, #78H						; SAVE THE HEXCODE (8085 INST. SET) OF THE INSTRUCTION 'MOV	A, B' 
					CALL		END_LOADER

					MOV			A, #79H						; SAVE THE HEXCODE (8085 INST. SET) OF THE INSTRUCTION 'MOV	A, C' 
					CALL		END_LOADER

					MOV			A, #7AH						; SAVE THE HEXCODE (8085 INST. SET) OF THE INSTRUCTION 'MOV	A, D' 
					CALL		END_LOADER

					MOV			A, #7BH						; SAVE THE HEXCODE (8085 INST. SET) OF THE INSTRUCTION 'MOV	A, E' 
					CALL		END_LOADER

					MOV			A, #7CH						; SAVE THE HEXCODE (8085 INST. SET) OF THE INSTRUCTION 'MOV	A, H' 
					CALL		END_LOADER

					MOV			A, #7DH						; SAVE THE HEXCODE (8085 INST. SET) OF THE INSTRUCTION 'MOV	A, L' 
					CALL		END_LOADER

					POP			DPL							; RETRIEVE THIER CONTENT 
					POP			DPH							; (ELOO CHECK IF THIS AND THE OTHER INSTRUCTION ABOVE IS NECESSARY)
; ELOO YOU MAY INCLUDE AT MOST 1 OR 2 SECONDS DELAY SO THAT THE LCD MESSAGE ABOVE MAY BE VISIBLE TO THE USER
					CLR_LCD
					D_STR									; DISPLAY THE FOLLOWING STRINGS ON LINE ONE (SINCE LCD DDRAM ADDRESS RESETS WHEN CLEARED)
					DB			'      Done!!!     ',0

					JNB			0CH, $						; JUST STAY HERE WHILE THE USER ANALYIZE HE/HER DATA

; ------------------------------------
END_LOADER:			INC			DPTR						; SEND TO THE EXTERNAL DATA MEM. THE HEXCODE (IN 8085uP INSTRUCTION SET) TO READ  
					MOVX		@DPTR, A					; THE CONTENT OF THE REGISTER TO BE EXAMINED AND PLACE IT IN 8085''s ACCUMMULATOR

					MOV			A, #32H						; SAVE THE HEXCODE (8085 INST. SET) OF THE INSTRUCTION 'STA ....'  
					INC			DPTR
					MOVX		@DPTR, A					; PLACE IN THE EXTERNAL DATA MEMORY

					MOV			A, @R0						; LOAD THE SECOND BYTE (LOB OF THE ADDRESS) FIRST AS ASSMBLEY PRINCIPLE DEMANDS
					INC			DPTR
					MOVX		@DPTR, A					; PLACE IN THE EXTERNAL DATA MEMORY

					MOV			A, @R1		 				; LOAD THE THIRD BYTE (HOB OF THE ADDRESS) SECOND AS ASSMBLEY PRINCIPLE DEMANDS					
					INC			DPTR
					MOVX		@DPTR, A					; PLACE IN THE EXTERNAL DATA MEMORY

					INC			R1							; GET READY FOR THE NEXT ADDRESS TRANSFER
					INC			R0

					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
; EXAMINE THE REGISTERS OF THE 8085uP (EXAM REG)
; THIS SUBROUTINE IS USED TO EXAMINE THE CONTENT OF THE 8085uP IN-BUILT REGISTERS (ie A, B, C, D, E, H & L)

; *** IT SHOULD BE INCLUDED IN THE MANUAL THAT THE USER SHOULD EXAMINE THE CONTENT OF THE ACCUMMULATOR FIRST BEFORE OTHER TO AVOID 
; *** LOSS OF ITS DATA SINCE IT IS THE ONE THAT DOES THE TRANFER

EXAM_REG:			
					CLR_LCD
					D_STR									; DISPLAY THE FOLLOWING STRINGS ON LINE ONE (SINCE LCD DDRAM ADDRESS RESETS WHEN CLEARED)
					DB			'Examine Register',0
					MOV			DPH, 41H				   	; PREPARE AN ADDRESS +2 GREATER THAN THE END ADDRESS FOR AUTO EXECUTION 
					MOV			DPL, 40H				   	; BY BOTH THE uC AND uP

					MOV			A, #0C0H					; THE INSTRUCTIONS BELOW DISPLAYS ON LINE 2
					CALL		LCD_CMD
					
ER_1:				CALL		KEYPAD_ID					; ENSURE A KEY(1ST KEY) IS DEPRESSED
					JNB			01H, ER_1
					CLR			01H							; GET READY FOR NEXT KEY
					
					CJNE		A, #'A', ER_2				; JUMP TO DISPLAY 'A' AND ITS CONTENT ELSE SKIP
					MOV			DPH, 43H					; THEY CONTAIN THE 16 BIT ADDRESS LOCATION WHERE THE CONTENT OF 'A' IS SAVED
					MOV			DPL, 42H					
					SJMP		ER_8
ER_2:				CJNE		A, #'B', ER_3				; JUMP TO DISPLAY 'B' AND ITS CONTENT ELSE SKIP
					MOV			DPH, 43H					; THEY CONTAIN THE 16 BIT ADDRESS LOCATION WHERE THE CONTENT OF 'B' IS SAVED
					MOV			DPL, 42H					
					SJMP		ER_8
ER_3:				CJNE		A, #'C', ER_4				; JUMP TO DISPLAY 'C' AND ITS CONTENT ELSE SKIP
					MOV			DPH, 43H					; THEY CONTAIN THE 16 BIT ADDRESS LOCATION WHERE THE CONTENT OF 'C' IS SAVED
					MOV			DPL, 42H					
					SJMP		ER_8
ER_4:				CJNE		A, #'D', ER_5				; JUMP TO DISPLAY 'D' AND ITS CONTENT ELSE SKIP
					MOV			DPH, 43H					; THEY CONTAIN THE 16 BIT ADDRESS LOCATION WHERE THE CONTENT OF 'D' IS SAVED
					MOV			DPL, 42H					
					SJMP		ER_8
ER_5:				CJNE		A, #'E', ER_6				; JUMP TO DISPLAY 'E' AND ITS CONTENT ELSE SKIP
					MOV			DPH, 43H					; THEY CONTAIN THE 16 BIT ADDRESS LOCATION WHERE THE CONTENT OF 'E' IS SAVED
					MOV			DPL, 42H					
					SJMP		ER_8
ER_6:				CJNE		A, #'H', ER_7				; JUMP TO DISPLAY 'H' AND ITS CONTENT ELSE SKIP
					MOV			DPH, 43H					; THEY CONTAIN THE 16 BIT ADDRESS LOCATION WHERE THE CONTENT OF 'H' IS SAVED
					MOV			DPL, 42H					
					SJMP		ER_8
ER_7:				CJNE		A, #'L', ER_1				; JUMP TO DISPLAY 'L' AND ITS CONTENT ELSE START AFRESH (KEY PRESSED NOT ACCESSABLE)
					MOV			DPH, 43H					; THEY CONTAIN THE 16 BIT ADDRESS LOCATION WHERE THE CONTENT OF 'L' IS SAVED
					MOV			DPL, 42H					

ER_8:				CALL		LCD_SHO						; DISPLAY THE REGISTERS' ALPAHBET INDICATOR FOLLOWED BY THE CHARATER ':'
					MOV			A, #':'
					CALL		LCD_SHO

					MOVX		A, @DPTR					; RETRIEVE THE HEX CODE IN THE ADDRESS SPECIFIED BY THE CONTENT OF THE DPTR
					MOV			36H, A						; PLACE THE HEX CODE INTO THE INPUT MEMORY LOC. (36H) OF THE HEX_2_ASCII SR

					CALL		HEX_2_ASCII					; CALL THE OSR FOR CONVERSION

					MOV			A, 38H						; MOVE THE ASCII CODE OF THE HIGHER ORDER BYTE TO FOR DISPLAY
					CALL		LCD_SHO
					MOV			A, 37H						; MOVE THE ASCII CODE OF THE LOWER ORDER BYTE TO FOR DISPLAY
					CALL		LCD_SHO


					AJMP		EXAM_REG					; START AFRESH

; ---------------------------------------------------------------------------------------------------------------------------------------
; EXECUTE (EXE)
; THIS IS A SR THAT COMMUNICATES WITH THE MICROPROCESSOR TELL IT TO CARRY OUT THE CODE LOADED IN THE EXTERNAL DATA MEMORY

; I MAY USE INTERRUPT IN THE 8085 TO DO THIS

EXE:			MOV			PCON, #01H				; ACTIVATE THE IDLE MODE
				RET

; ---------------------------------------------------------------------------------------------------------------------------------------
FLY_ADDRESS:
					CALL 		LCD_SHO						; SHOW THE LAST ALPHABET OF TGHE OPCODE (DISPLAY THE CHARATER IN 'A' FROM THE CALLER PROGRAM)
FLY_ADDRESS_SKIP:
					CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED
					JNB			01H, FLY_ADDRESS_SKIP
					CLR			01H							; GET READY FOR NEXT KEY

					CJNE		A, #'*', FLY_ADDRESS_SKIP	; ENSURES NEXT IS USE TO GIVE SPACE
					MOV			A, #' '						; GIVE A GAP				   
					CALL 		LCD_SHO
					CLR			03H							; SELECT OPCODE TYPE IN THE 'NEXT SR'
					CALL		NEXT						; CALL NEXT OSR TO PERMANENTLY SAVE THE OPCODE'S CODES
FLY_SUB_MEM:					
					MOV			32H, #04H					; ENSURES THAT ONLY FOUR NIBBLES (ie 2 BYTE DATA) ARE ENTERED
					SETB		04H							; SET THE BYTE INDICATOR FOR A 2 BYTE(4 NIBBLE) OPERAND CONVERSION
					SETB		06H							; SET FLAG TO CAUSE THE ASCII_2_HEX SR TO CARRY OUT HIGH ORDER BYTE MARRIAGE FIRST

FA_1:				CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED
					JNB			01H, FA_1
					CLR			01H							; GET READY FOR NEXT KEY

					JNB			08H, FA_CONTINUE			; IF IT IS NOT SUB MEM PASSING THIS SEGMENT SKIP THE SEGMENT
					CLR			05H							; REFRESH THE BYTE MARRIAGE FLAG. IT HELPS THE CANCEL SR
					CJNE		A, #'N', FA_CONTINUE		; ELOO NOTE THAT THE FOLLOWING 3 INSTRUCTION IS SOLELY FOR SUB MEM'S CANCEL
					CLR_LCD
					SJMP		FLY_SUB_MEM

FA_CONTINUE:		CALL		ASCII_2_HEX					; DO THE CONVERSION AND COMPARE
					JNB			02H, FA_1					; ENSURES THAT THE KEY PRESSED IS BETWEEN 0 - F IN HEX
					CLR			02H							; GET READY FOR NEXT KEY

					MOV 		A,31H						; DISPLAY THE NUMBER
					CALL		LCD_SHO
					DJNZ		32H, FA_1					; CHECK IF FOUR NIBBLES (TWO BYTES) DATA HAVE BEEN ENTERED

FA_2:				CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED
					JNB			01H, FA_2
					CLR			01H							; GET READY FOR NEXT KEY
					CJNE		A, #'*', FA_2				; ENSURES NEXT IS PRESSED TO CONTINUE

					JB			00H, FA_EXIT				; SKIP THE SR SEGMENT BELOW IF IT IS A SUB MEM CALL

					SETB		03H							; SELECT OPERAND TYPE IN THE 'NEXT SR' (NOT OPCODE TYPE)
					SETB		07H							; SELECT ADDRESS TYPE OPERAND IN THE 'NEXT SR'
					CALL		NEXT						; CALL NEXT OSR TO PERMANENTLY SAVE THE OPERAND CODES
					CALL		ADDRESS_DISPLAY_CONTROL		; CALL THIS OSR TO CLEAR THE LCD SCREEN AND WRITE THE NEW ADDRESS IN LINE 1
FA_EXIT:																		   
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
FLY_DATA:
; THIS SUBROUTINE IS SUPPOSE TO CARRY PROGRAMS FOR THE DISPLAY OF ',' & ' '(SPACE)
; BEFORE THE INPUT DATA
					CALL 		LCD_SHO						; SHOW THE LAST ALPHABET OF THE OPCODE (DISPLAY THE CHARATER IN 'A' FROM THE CALLER PROGRAM)
FLY_DATA_SKIP:												; SKIPS THE INSTRUCTION 'CALL LCD_SHO'
					CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED
					JNB			01H, FLY_DATA_SKIP
					CLR			01H							; GET READY FOR NEXT KEY
					
					CJNE		A, #'*', FLY_DATA_SKIP		; ENSURES NEXT IS USE TO GIVE SPACE
					MOV			A, #','						; PLACE A COMMA				   
					CALL 		LCD_SHO
					MOV			A, #' '						; GIVE A GAP				   
					CALL 		LCD_SHO
					CLR			03H							; SELECT OPCODE TYPE IN THE 'NEXT SR'
					CALL		NEXT
					
					MOV			32H, #02H					; ENSURES THAT ONLY TWO NIBBLES (ie 1 BYTE DATA) ARE ENTERED
					CLR			04H							; CLEAR THE BYTE INDICATOR FOR A 1 BYTE(2 NIBBLE) OPERAND CONVERSION

FD_1:				CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED
					JNB			01H, FD_1
					CLR			01H							; GET READY FOR NEXT KEY

					CALL		ASCII_2_HEX					; DO THE CONVERSION AND COMPARE
					JNB			02H, FD_1					; ENSURES THAT THE KEY PRESSED IS BETWEEN 0 - F IN HEX
					CLR			02H							; GET READY FOR NEXT KEY

					MOV 		A,31H						; DISPLAY THE NUMBER
					CALL		LCD_SHO
					DJNZ		32H, FD_1					; CHECK IF TWO NIBBLES (ONE BYTE) DATA HAVE BEEN ENTERED

FD_2:				CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED
					JNB			01H, FD_2
					CLR			01H							; GET READY FOR NEXT KEY
					CJNE		A, #'*', FD_2				; ENSURES NEXT IS USE TO GIVE SPACE
					SETB		03H							; SELECT OPERAND TYPE 'NEXT SR' (NOT OPCODE TYPE)
					CLR			07H							; SELECT DATA TYPE OPERAND IN THE 'NEXT SR'
					CALL		NEXT						; CALL NEXT OSR TO PERMANENTLY SAVE THE OPCODE
					CALL		ADDRESS_DISPLAY_CONTROL		; CALL THIS OSR TO CLEAR THE LCD SCREEN AND WRITE THE NEW ADDRESS IN LINE 1

					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
FLY_OPCODE:
; THIS IS A SUBROUTINE THAT IS DEDICATED TO 8085 INST. SETS THAT HAS NO OPERAND
		
					CALL 		LCD_SHO	
FLY_OPCODE_SKIP:
					CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED
					JNB			01H, FLY_OPCODE_SKIP
					CLR			01H							; GET READY FOR NEXT KEY
					CJNE		A, #'*', FLY_OPCODE_SKIP	; ENSURES NEXT IS TO INPUT THE CODE TO HE EXTERNAL MEMORY
					CLR			03H							; SELECT OPCODE TYPE IN THE 'NEXT SR'
					CALL		NEXT						; CALL NEXT OSR TO PERMANENTLY SAVE THE OPCODE IN THE EXTERNAL MEMORY
					CALL		ADDRESS_DISPLAY_CONTROL		; CALL THIS OSR TO CLEAR THE LCD SCREEN AND WRITE THE NEW ADDRESS IN LINE 1

					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
GET_READY:
; THIS SUBROUTINE CHECKS BUSY FLAG (P0.7=D7) TO ENABLE COMMAND OR DATA LATCH-IN
; SFR BITS: P0.7 (D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
					SETB 		P0.7 						; MAKE P1.7 INPUT PORT
					CLR 		P2.5	 					; RS=0 ACCESS LCD COMMAND REG
					SETB 		P2.6 						; R/W=1 READ COMMAND REG
															; READ COMMAND REG AND CHECK BUSY FLAG
BACK:	
					CLR 		P3.3	 					; E=0 L-TO-H PULSE
					SETB 		P3.3 						; E=1 FOR L-TO-H PULSE
					JB 			P0.7, BACK					; STAY UNTIL BUSY FLAG=0
					RET										; RETURN TO THE CALLER PROGRAM

; ---------------------------------------------------------------------------------------------------------------------------------------
; GO_TO (GO TO)
; THIS A SR THE SELECTS OR GIVE THE USER THE OPPORTUNITY TO EXAMINE A PARTICULAR PART OF A PROGRAM
; USE UNDER THE V_HEX(VIEW HEX) MODE ONLY

GO_TO: 
					CLR			IE.7						; DISABLE THE EXTERNAL INTERRUPT(!INT0) USING THE GLOBAL IE BIT
					CLR			05H							; REFRESH THE BYTE MARRIAGE FLAG. IT HELPS THE CANCEL SR

					CLR_LCD									; CLEAR THE LCD SCREEN
					D_STR									; DISPLAY THE FOLLOWING STRINGS
					DB			'GO TO: ',0

					MOV			32H, #04H					; ENSURES THAT ONLY FOUR NIBBLES (ie 2 BYTE DATA) ARE ENTERED
					SETB		04H							; SET THE BYTE INDICATOR FOR A 2 BYTE(4 NIBBLE) ADDRESS CONVERSION
					SETB		06H							; SET FLAG TO CAUSE THE ASCII_2_HEX SR TO CARRY OUT HIGH ORDER BYTE MARRIAGE FIRST

GT_1:				CALL 		KEYPAD_ID  					; ENSURE THAT A KEY IS PRESSED
					JNB			01H, GT_1
					CLR			01H							; GET READY FOR THE NEXT KEY

					CJNE		A, #'N', GT_2				; ELOO NOTE THAT THE FOLLOWING 3 INSTRUCTION IS SOLELY FOR GOTO'S CANCEL
; IF 'N' IS PRESSED (ie CANCEL) RETURN TO THE CALL PROGRAM
					SJMP		EXIT_GOTO					; ESCAPE THE OSR(GOTO)

GT_2:				CALL		ASCII_2_HEX					; DO THE CONVERSION AND COMPARE
					JNB			02H, GT_1					; ENSURES THAT THE KEY PRESSED IS BETWEEN 0 - F IN HEX
					CLR			02H							; GET READY FOR NEXT KEY

					MOV 		A,31H						; DISPLAY THE NUMBER
					CALL		LCD_SHO
					DJNZ		32H, GT_1					; CHECK IF FOUR NIBBLES (TWO BYTES) DATA HAVE BEEN ENTERED

GT_3:				CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED
					JNB			01H, GT_3
					CLR			01H							; GET READY FOR NEXT KEY
					
; WAIT FOR NEXT OR CANCEL
					CJNE		A, #'N', GT_4				; ENSURES NEXT IS PRESSED TO CONTINUE OR 'N' TO ESCAPE THE OSR
					SJMP		EXIT_GOTO					; ESCAPE THE OSR(GOTO)

GT_4:				CJNE		A, #'*', GT_3			    ; ACCEPT USER'S INPUT ADDRESS FOR TEST

; COMPARE ADDRESS WITH THE START ADDRESS MEM LOCS.
					MOV			A, 3FH						; LOAD THE START ADDRESS HOB FOR COMPARISON	WITH GOTO'S HOB ADDRESS
					CJNE		A, 35H, GT_5
					SJMP		GT_6						; IF EQUAL JUMP TO TEST THE LOB(THIS IS DONE ONLY FOR EQUALITY ENCOUTERED)
GT_5:				JNC			OUT_OF_RANGE				; EXIT IF START ADDRESS HOB IS GREATER THAN THE GOTO'S HOB ADDRESS
					SJMP		GT_8						; SKIP LOB ADDRESS TEST, CONTINUE WITH THE END ADDRESS TEST

GT_6:				MOV			A, 3EH						; LOAD THE START ADDRESS LOB FOR COMPARISON	WITH GOTO'S LOB ADDRESS
					CJNE		A, 34H, GT_7
					SETB		C
GT_7:				JNC			OUT_OF_RANGE				; EXIT IF START ADDRESS LOB IS GREATER THAN THE GOTO'S LOB ADDRESS 
															; ELSE CONTINUE
; COMPARE ADDRESS WITH THE END ADDRESS MEM LOCS.
GT_8:				MOV			A, 41H						; LOAD THE END ADDRESS HOB FOR COMPARISON WITH GOTO'S HOB ADDRESS
					CJNE		A, 35H, GT_9
					SJMP		GT_10						; IF EQUAL JUMP TO TEST THE LOB(THIS IS DONE ONLY FOR EQUALITY ENCOUTERED)
GT_9:				JC			OUT_OF_RANGE				; EXIT IF END ADDRESS HOB IS GREATER THAN THE GOTO'S HOB ADDRESS
					SJMP		GT_12						; SKIP LOB ADDRESS TEST, AND CARRY OUT A JUMP TO THE USER'S DESIRED ADDRESS

GT_10:				MOV			A, 40H						; LOAD THE END ADDRESS LOB FOR COMPARISON WITH GOTO'S LOB ADDRESS
					CJNE		A, 34H, GT_11
					CLR			C
GT_11:				JC			OUT_OF_RANGE				; EXIT IF END ADDRESS LOB IS GREATER THAN THE GOTO'S LOB ADDRESS ELSE CONTINUE
; ALL TESTS HAVE BEEN COMPLETED
															; ACCEPT USER'S INPUT ADDRESS AND EXIT
GT_12:				MOV			3DH, 35H					; LOAD THE USER'S DESIRED ADDRESS(HOB) INTO THE V_HEX CURRENT ADDRESS MEM LOC.2(HOB)
					MOV			3CH, 34H					; LOAD THE USER'S DESIRED ADDRESS(LOB) INTO THE V_HEX CURRENT ADDRESS MEM LOC.1(LOB)
					SJMP		EXIT_GOTO
OUT_OF_RANGE:			
					CLR_LCD									; CLEAR THE LCD SCREEN
					D_STR									; DISPLAY THE FOLLOWING STRINGS
					DB			'  Out Of Range  ',0
					CALL		DELAY_2S					; DELAY FOR THE USER TO SEE THE MESSAGE
					AJMP		GO_TO						; START AFRESH
EXIT_GOTO:
					SETB		IE.7						; NOW ENABLE THE EXTERNAL INTERRUPT
					RET
		; IF THE ADDRESS PUT BY THE USER PASS THE TEST OF COMPARISON LOAD THE APPROPRIATE MEM LOCS WITH THE ADDRESS AND EXIT THE OSR
		; ELSE DISPLAY THE FOLOWING MESSAGE: 'OUT OF RANGE' FOR TWO SECONDS (USE 1SEC X 2) THEN JUMP BACK TO BLANK THE LCD SCREEN
; ---------------------------------------------------------------------------------------------------------------------------------------
HEX_2_ASCII:
; THIS A SR THAT TAKES CARE OF GENERATING THE EQUIVALENT ASCII CODE FROM A HEX INPUT CODE
				; HIGH ORDER BYTE CONVERSION BEGINS	HERE
				MOV			A, 36H					; LOAD THE HEX BYTE TO BE CONVERTED INTO 'A'
				ANL			A, #0F0H				; MASK THE LOW ORDER BYTE
				SWAP		A						; HOB <==> LOB
				CJNE		A, #0AH, H2A_1
				CLR			C
													; IF 'A' >= 0AH	DO THE FOLLOWING INSTRUCTIONS
H2A_1:			JC			H2A_2					; ADD 07H & LATER 30H 
				ADD			A, #07H					; (RAISE THE CONTENT OF 'A' TO THE NUMERICAL VALUE OF ITS EQUIVALENT ASCII CODE)

													; IF 'A' < 0AH DO THE FOLLOWING INSTRUCTIONS
H2A_2:			ADD			A, #30H				   	; ADD 30H (RAISE THE CONTENT OF 'A' TO THE NUMERICAL VALUE OF ITS EQUIVALENT ASCII CODE) 

				MOV			38H, A					; SAVE THE ASCII CODE OF THE HIGH ORDER BYTE IN MEM. 38H
													; HIGH ORDER BYTE CONVERSION ENDS HERE

				; LOW ORDER BYTE CONVERSION BEGINS HERE
				MOV			A, 36H					; LOAD THE HEX BYTE TO BE CONVERTED INTO 'A'
				ANL			A, #0FH					; MASK THE HIGH ORDER BYTE
				CJNE		A, #0AH, H2A_3
				CLR			C
													; IF 'A' >= 0AH	DO THE FOLLOWING INSTRUCTIONS
H2A_3:			JC			H2A_4					; ADD 07H & LATER 30H 
				ADD			A, #07H					; (RAISE THE CONTENT OF 'A' TO THE NUMERICAL VALUE OF ITS EQUIVALENT ASCII CODE)

													; IF 'A' < 0AH DO THE FOLLOWING INSTRUCTIONS
H2A_4:			ADD			A, #30H				   	; ADD 30H (RAISE THE CONTENT OF 'A' TO THE NUMERICAL VALUE OF ITS EQUIVALENT ASCII CODE) 

				MOV			37H, A					; SAVE THE ASCII CODE OF THE LOWER ORDER BYTE IN MEM. 37H

													; LOW ORDER BYTE CONVERSION ENDS HERE
				RET

; TESTED: QC PASSED SYNTAXICALLY AND SEMANTICALLY

; ---------------------------------------------------------------------------------------------------------------------------------------
INTRO_CPLT:			
;					MOV			A, #80H						; THIS INSTRUCTION MY NOT BE RELEVANT SINCE THIS MESSAGE IS CALLED IMMEDIATELY AFTER 
					D_STR									; A LCD SCREEN CLEAR THUS DDRAM ADDRESS AUTOMATICALLY RESETS TO LINE 1
					DB			'   SBC 8085uP   ',0		; LINE 1
					MOV			A, #0C0H					; SET DDRAM ADDRESS TO LINE 2
					CALL		LCD_CMD				  
					D_STR									; DISPLAY THE FOLLOWING STRINGS
					DB			'by IFEDIORA E.C.',0		; LINE 2
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
INTRO_MSG:
;
;
;					MOV			A, #80H						; THIS INSTRUCTION MY NOT BE RELEVANT SINCE THIS MESSAGE IS CALLED IMMEDIATELY AFTER 
					D_STR									; A LCD SCREEN CLEAR THUS DDRAM ADDRESS AUTOMATICALLY RESETS TO LINE 1
					DB			'Press 0 for MHEX',0		; LINE 1
					MOV			A, #0C0H					; SET DDRAM ADDRESS TO LINE 2
					CALL		LCD_CMD				  
					D_STR									; DISPLAY THE FOLLOWING STRINGS
					DB			'Press 1 for ASM',0		    ; LINE 2
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
INTRO_SUBMEM_REQUEST:
;				
					D_STR									; DISPLAY THE FOLLOWING STRINGS 
					DB			'Enter Start Addr',0		; LINE 1
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
KEYPAD_ID:
; THIS SUBROUTINE RETRIEVES DATA FROM THE KEYPAD AND IDENTIFIES THE KEY PRESSED
; IT STORES THE ASCII CODE OF THE KEY PRESSED IN THE CHARACTER DISPLAY MEMORY (ie CDM 31H)
; IT ALSO HAS IN IT SOME STATUTORY FLAGS SUCH AS: 01H(KEY PRESSED FLAG),
; ALSO HAS IN IT SOME STATUTORY MEMORY LOC SUCH AS: 30H(SUB MEM DELAY COUNTER 4 X 500ms), LOAD #01H IF KEY IS PRESSED

; ****************************** KEYPAD_ID
				MOV   	P1, #00H				; MAKE P1 OUTPUT
				MOV		P3, #0FFH				; MAKE P3.0, P3.1, P3.4 & P3.5 INPUT PORTS AND SECURE THE OTHER PINS' SETTINGS
				MOV   	A, P3			 		; READ THE ROW
;				ANL  	A,#0FFH				 	; MASK THE 4 MSB (3 COLUMNS & 1(P1.7) EMPTY PIN)
				CJNE  	A,#0FFH,KEY2				; IS ANY KEY DEPRESSED? IF 'NO' RETURN TO KEYPAD_ID ELSE JUMP TO KEY2 FOR COMFIRMATION
				JMP   	KEYFNL					; THE ABOVE SEGMENT ENSURES THAT KEYPAD IS FREE BEFORE A NEW SCAN IS CARRIED OUT
KEY2:	
				CALL  	LCD_DLY				 	; DELAY TO DEBOUNCE KEYPAD
				MOV   	P1, #00H				; MAKE P1 OUTPUT
				MOV		P3, #0FFH				; MAKE P3.0, P3.1, P3.4 & P3.5 INPUT PORTS AND SECURE THE OTHER PINS' SETTINGS
				MOV   	A,P3				 	; READ THE ROW AGAIN TO COMFIRM KEY DEPRESSED 
;				ANL   	A,#0FFH					; MASK THE FOLLOWING BITS' RESULTS READ FROM P3: D2, D3, D6 & D7 (THEY ARE NOT FROM ROW PINS)
				CJNE  	A,#0FFH,KEY3			; IS ANY KEY DEPRESSED? IF 'NO' RETURN TO KEYPAD_ID ELSE JUMP TO KEY3 FOR IDENTIFICATION
				JMP   	KEYFNL
; ****************************** ROW SCAN STARTS
KEY3:
				MOV   	R5,#06H					; LOAD 6 INTO R5 FOR ROW SCAN (NEEDED SCAN = 4 OF 6; THE OTHER 2 AT THE MIDDLE ARE USELESS)
				ORL		A, #0CCH				; #0CCH = 11001100B. THIS IS DONE TO PURPOSELY SKIP (PARTICULARLY) P3.2 & P3.3
												; P3.6 & P3.7 HAS BEEN TAKEN CARE OF (ie SKIP) BY THE BOTH INSTRUCTIONS JUST ABOVE
KEY31:	
				RRC   	A						; SCAN EACH OF THE 4 ROWS
				JNC   	KEY4					; IF CY = 0, A KEY HAS BEEN DEPRESSED ON THAT ROW JUMP TO KEY4 ELSE CONTINUE
				DJNZ  	R5,KEY31				; SCAN NEXT ROW
KEY4:
				CJNE  	R5,#6,KEY41				; IF R5 = 6 LOAD ROW_1 ADDRESS AND JUMP TO KEY41 ELSE JUMP TO KEY5
				MOV   	DPTR,#ROW_1
				JMP   	KEY5
KEY41:	
				CJNE  	R5,#5,KEY42				; IF R5 = 5 LOAD ROW_2 ADDRESS AND JUMP TO KEY42 ELSE JUMP KEY5
				MOV   	DPTR,#ROW_2
				JMP   	KEY5
KEY42:	
				CJNE  	R5,#2,KEY43				; IF R5 = 2 LOAD ROW_3 ADDRESS AND JUMP TO KEY43 ELSE JUMP KEY5
				MOV   	DPTR,#ROW_3
				JMP   	KEY5
KEY43:	
				CJNE  	R5,#1,KEY44				; IF R5 = 1 LOAD ROW_4 ADDRESS AND JUMP TO KEY44 ELSE JUMP KEY5
				MOV   	DPTR,#ROW_4
				JMP   	KEY5
KEY44:											
				JMP  	KEYFNL					; ERROR! RETURN TO KEYPAD_ID (NO KEY DEPRESSED)
; *************************** COLUMN SCAN STARTS
KEY5:									
				MOV   	P3, #0FFH				; MAKE ALL INPUT (IT MAY MEAN CLEAR, JUST COMFIRM LATER!)
				MOV   	P1, #00H				;  
				MOV		P3, #0FFH				; MAKE P3 OUTPUT NOW
				MOV   	A, P1					; READ P1
KEY6:										
				MOV   	R5,#9					; LOAD 9 INTO R5 FOR COLUMN SCAN
KEY61:	
				RRC   	A						; SCAN EACH OF THE 8 COLUMNS
				JNC   	KEY7					; IF CY = 0, A KEY HAS BEEN DEPRESSED ON THAT COLUMNS JUMP TO KEY7 ELSE CONTINUE
				DJNZ  	R5,KEY61				; SCAN NEXT COLUMN
				JMP   	KEYFNL					; ERROR! RETURN TO KEYPAD_ID (NO KEY DEPRESSED)
; *****************************LOAD DATA ADDRESS	
KEY7:
				CJNE  	R5,#9,KEY71				; IF R5 ~= 9 CONTINUE ELSE JUMP TO KEY71
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA. REMEMBER DPTR CONTAINS X00H ADRRESS HERE
												; THUS THE DISPARITY WHILE INCREMENT OCCUR ALONG (DOWN THE PROGRAM)
KEY71:	
				CJNE 	R5,#8,KEY72				; IF R5 ~= 8 CONTINUE ELSE JUMP TO KEY72
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR ONCE FOR COLUMN 2
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY72:	
				CJNE  	R5,#7,KEY73				; IF R5 ~= 7 CONTINUE ELSE JUMP TO KEY73
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR TWICE FOR COLUMN 3
				INC   	DPTR
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY73:	
				CJNE  	R5,#6,KEY74 			; IF R5 ~= 6 CONTINUE ELSE JUMP TO KEY74
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR THRICE FOR COLUMN 4
				INC   	DPTR
				INC   	DPTR	
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY74:	
				CJNE  	R5,#5,KEY75 			; IF R5 ~= 5 CONTINUE ELSE JUMP TO KEY75
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR 4 TIMES FOR COLUMN 5
				INC   	DPTR
				INC   	DPTR	
				INC   	DPTR
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY75:	
				CJNE  	R5,#4,KEY76 			; IF R5 ~= 4 CONTINUE ELSE JUMP TO KEY76
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR 5 TIMES FOR COLUMN 6
				INC   	DPTR
				INC   	DPTR	
				INC   	DPTR
				INC   	DPTR
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY76:	
				CJNE  	R5,#3,KEY77 			; IF R5 ~= 3 CONTINUE ELSE JUMP TO KEY77
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR 6 TIMES FOR COLUMN 7
				INC   	DPTR
				INC   	DPTR	
				INC   	DPTR
				INC   	DPTR
				INC   	DPTR
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY77:	
				CJNE  	R5,#2,KEY78 			; IF R5 ~= 2 CONTINUE ELSE JUMP TO KEY78
				INC   	DPTR					; INCREMENT ADDRESS ALREADY IN DPTR 7 TIMES FOR COLUMN 8
				INC   	DPTR
				INC   	DPTR
				INC   	DPTR
				INC   	DPTR
				INC   	DPTR
				INC   	DPTR	
				JMP   	KEY8					; JUMP TO KEY8 AND PROVIDE DATA
KEY78:
				JMP   	KEYFNL					; RETURN TO KEYPAD_ID
KEY8:
				MOV   	P1, #00H				; MAKE P1 OUTPUT
				MOV		P3, #0F7H				; MAKE P3.0, P3.1, P3.4 & P3.5 INPUT PORTS AND SECURE THE OTHER PINS' SETTINGS
				MOV   	A, P3			 		; READ THE ROW
				CJNE  	A,#33H,KEY8				; IS ANY KEY DEPRESSED? IF 'NO' RETURN TO KEYPAD_ID ELSE JUMP TO KEY2 FOR COMFIRMATION
												; THE 4 INSTRUCTIONS JUST ABOVE IS USED TO PREVENT REPETITIVE DISPLAY ON KEY HOLD DOWN

				MOV   	A,#0					; CLEAR THE ACCUMULATOR
				MOVC  	A,@A+DPTR				; LOAD THE CODE FOR DISPLAY
				CALL  	LCD_SHO					; CALL SUBROUTINE TO DISPLAY DATA

KEYFNL:
				RET								; RETURN TO KEYPAD_ID

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_CMD:
; THIS SUBROUTINE SENDS THE ASCII CODE FOR THE COMMAND CHARATER TO BE DISPLAYED ON THE LCD
; IT CALLS READY (OSR) TO CHECK BUSY FLAG FOR COMMAND TO BE LATCHED-IN
; OPERATING REGISTER: A
; SFR BITS: P0 (LCD DATA PORT D0-D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
 
					ACALL 		GET_READY 					; IS LCD READY?
					MOV   		P0, A						; LATCH COMMAND INTO LCD DATA PORT	  
					CLR   		P2.5						; RS=0 ACCESS LCD DATA REG
					CLR			P2.6						; WRITE
					SETB  	 	P3.3						; H-TO-L PULSE TO LATCH-IN
					CLR   		P3.3						; H-TO-L PULSE TO LATCH-IN
					RET										; RETURN TO THE CALLER PROGRAM

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_DLY:
					MOV   		50H,#50
HERE2:
					MOV   		51H,#50
HERE1:
					DJNZ   		51H,HERE1	
					DJNZ   		50H,HERE2
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_SET:
; THIS SUBROUTINE SETS THE MODE OF OPERATION OF THE LCD
; IT CALLS LCD_CMD OSR TO LATCH-IN THE COMMAND
; OPERATING REGISTER: A
					MOV   		A, #38H						; 5 X 7 MATRIX DISPLAY
					CALL   		LCD_CMD						; LATCH COMMAND JUST ABOVE INTO THE LCD
					MOV   		A, #80H						; DISPLAY ON LINE 1
					CALL   		LCD_CMD						; LATCH COMMAND JUST ABOVE INTO THE LCD
					MOV   		A, #06H						; INCREMENT FROM LEFT TO RIGHT
					CALL   		LCD_CMD						; LATCH COMMAND JUST ABOVE INTO THE LCD
					RET										; RETURN TO THE CALLER PROGRAM

; ---------------------------------------------------------------------------------------------------------------------------------------
LCD_SHO:
; THIS SUBROUTINE SENDS THE ASCII CODE FOR THE DATA CHARATER TO BE DISPLAYED ON THE LCD
; IT CALLS READY (OSR) TO CHECK BUSY FLAG FOR DATA TO BE LATCHED-IN
; OPERATING REGISTER: A
; SFR BITS: P0 (LCD DATA PORT D0-D7), P2.5 (RS), P2.6 (R/!W), P3.3 (EN)
					ACALL 		GET_READY 					; IS LCD READY?
					MOV   		P0, A						; LATCH DATA INTO LCD DATA PORT	
					SETB   		P2.5						; RS=1, ACCESS LCD DATA REG
					CLR			P2.6						; R/!W=0, WRITE
					SETB   		P3.3						; H-TO-L PULSE TO LATCH-IN
					CLR   		P3.3						; H-TO-L PULSE TO LATCH-IN
					RET

; ---------------------------------------------------------------------------------------------------------------------------------------
; =*=*=*=*=*=*=*=*=*=*=*=*=*   MACHINE LANGUAGE (IN HEX, MHEX) AS THE CODE/PROGRAMMING LANGUAGE TYPE (CPLT)  =*=*=*=*=*=*=*=*=*=*=*=*=*=
; THIS MANIS SEGMENT/SUBROUTINE IS DEDICATED FOR MHEX
; THE CHOICE WOULD ALWAYS BE BETWEEN MACHINE LANGUAGE (IN HEX, MHEX) AND ASSEMBLY LANGUAGE (ASM)
; A TEST FLAG SHOULD COME AFTER SUB MEM FLAG IN THE MAIN PROGRAM

M_HEX:			
; ELOO PLEASE INCLUDE THE INSTRUCTIONS TO CARRY OUT DISPLAY ON LINE 2 HERE
				CALL		KEYPAD_ID						; ENSURE A KEY(1ST KEY) IS DEPRESSED
				JNB			01H, M_HEX
				CLR			01H								; GET READY FOR NEXT KEY

				CJNE		A, #30H, MH_1					; THE CONTENT OF 'A' MUST SATISFY THE FOLLOWING INEQUALITY: 30H =< A =< 46H
				CLR			C								; ENSURE IT PASSES TO THE NEXT INSTRUCTION

MH_1:			JC			M_HEX							; IF A > 30 CONTINUE ELSE GO BACK TO MHEX
				SUBB		A, #30H 						; SUBTRACT 30H FROM A REGISTER
				CJNE		A, #0AH, MH_2					
				CLR			C 								; ENSURE IT PASSES TO THE NEXT INSTRUCTION

MH_2:			JC			MH_4
				SUBB		A, #07H							; SUBTRACT 07H FROM 'A' REGISTER
				CJNE		A, #0FH, MH_3					; CHECK IF THE RESULT OF THE SUBTRACTION IS GREATER THAN 0FH; IF SO EXIT THE SR ELSE CONTINUE
				SETB		C								; ENSURE IT PASSES TO THE NEXT INSTRUCTION

MH_3:			JNC			M_HEX							; START AFRESH (ie MHEX) IF THE KEYPAD INPUT DOES NOT SATISFY THE ABOVE INEQUALITY
															; ELSE CONTINUE
MH_4:			CPL			0AH								; FORMAT THE DATA AND SAVE TEMPORARILY IN THE MEM LOC 33H
				JNB			0AH, MH_5
				SWAP		A
				MOV			33H, A							
				SJMP		MH_6							; SKIP OPERATIONS IN LABEL MHEX_5

MH_5:			ORL			A, 33H							; FORMAT COMPLETED
				MOV			33H, A							; CARRY OUT THE FINAL SAVE
				
MH_6:			MOV			A, 31H							; LOAD THE ASCII CODE FOR THE CURRENT CHARARTER TO BE DISPLAYED
				CALL		LCD_SHO

				DJNZ		3BH, M_HEX						; DECREMENT AND JUMP TILL ZERO TO CONTINUE

MH_7:			CALL		KEYPAD_ID						; ENSURE A KEY IS DEPRESSED
				JNB			01H, MH_7
				CLR			01H	

				CJNE		A, #'*', MH_7					; WAIT FOR 'NEXT KEY' TO BE PRESSED

				MOV			3BH, #02H						; LOAD ANOTHER TWO DIGIT COUNT INTO MHC FOR THE NEXT INPUT (INSTRUCTION SET)

				CLR			03H								; SELECT OPCODE TYPE IN THE 'NEXT SR'
				CALL		NEXT							; CALL NEXT OSR TO PERMANENTLY SAVE THE HEX CODE IN THE EXTERNAL MEMORY
				CALL		ADDRESS_DISPLAY_CONTROL			; CALL THIS OSR TO CLEAR THE LCD SCREEN AND WRITE THE NEW ADDRESS IN LINE 1

				AJMP		M_HEX							
; ELOO U MAY PUT UR FLAG FOR SUB MEM ASCII_2_HEX SR CALL HERE(NOTE SUCH FLAG MUST BE CLEAR AT THE SUB MEM SR ON RETURN IMMEDIATELY)
; EXPECTED FLAG INSTRUCTION: JB		SubMem'sAscii2hexFlag, EXIT_A2H

; THE TEST IS COMPLETED. THE INEQUQLITY: 30H =< A =< 46H HAS BEEN SATISFIED AND CONVERSION HAS TAKEN PLACE!!!

; ---------------------------------------------------------------------------------------------------------------------------------------
; THIS SUBROUTINE LOADS THE APPROPRIATE OPCODE OR OPERAND(ie DATA OR ADDRESS) INTO THEIR PERMANENT LOCATION
; IT DIFFRENETIATES OPCODE CALL FROM AN OPERAND CALL BY USING THE NEXT TYPE FLAG (ie NCF 03H)
; WHEN IT IS SET IT CALLS THE OPERAND ELSE THE OPCODE, NCF IS TESTED AT THE ENTRANCE TO THE SR 
; IT ALSO HANDLES THE SUB MEM START ADDRESS INTIALIZATION 

; THIS IS THE SR WHERE MEMORY ADDRESS INCREMENT DISPLAY REGISTER IS TO BE CONFIGURED
; ***ON ERROR AFTER TESTING THIS SR CHANGE DPH = 83H, & DPL = 82H(DIRECT ADDRESSING)

; ****REMEMBER TO SAVE REGS & FLAGS STILL RELEVANT TO THE CALLER PROGRAM TO AVOID DATA LOSS****

NEXT:			

				JB			08H, NEXT_4_SUB_MEM		   	; CHECK WHETHER CALLER PROGRAM IS SUB MEM OR OTHERS AND JUMP APTLY
				SJMP		NEXT_4_OPCODE
NEXT_4_SUB_MEM:
				; LOAD THE USER'S DESIRED START CODE ADDRESS IN THE DATA POINTER'S HIGH AND LOWER ORDER REG.
				

				MOV			3AH, 35H					; LOAD THE HIGH ORDER BYTE INTO NEXT ADDRESS HOLDER/ADDRESS_DISPLAY_CONTROL'S INPUT MEM LOC 2 FOR DISPLAY 
				MOV			39H, 34H					; LOAD THE LOW ORDER BYTE INTO NEXT ADDRESS HOLDER/ADDRESS_DISPLAY_CONTROL'S INPUT MEM LOC 1 FOR DISPLAY

				MOV			3FH, 35H					; LOAD THE HIGH ORDER BYTE INTO THE V_HEX DISPLAY ADDRESS MEM LOC 2
				MOV			3EH, 34H					; LOAD THE LOWER ORDER BYTE	INTO THE V_HEX DISPLAY ADDRESS MEM LOC 1

				MOV			43H, 35H					; SAVE THE CURRENT ADDRESS IN THE PAGE MEMORY (HOB)
				MOV			42H, 34H					;											  (LOB)

				MOV			41H, 35H				   	; THE END ADDRESS (PREPARE AN ADDRESS +1 GREATER THAN ITSELF) FOR AUTO EXAM REG... 
				MOV			40H, 34H				   	; BY BOTH THE uC AND uP AFTER 'END' IS PRESSED

				; THE MEM. LOCATIONS TO BE USED HERE ARE 34H & 35H (BECAUSE THEY CONTAIN THE CURRENT LOW & HIGH ORDER ADDRESS RESPECTIVELY)
				; LOAD IT INTO A REGISTER (EXTERNAL TRANSFER REGISTER) THAT CAN COMMUNICATE WITH THE OUTSIDE WORLD(I MEAN OUTSIDE THE MICROCONTROLLER)

				CLR			08H							; CLEAR THE NEXT SUB MEM FLAG (IS IT NECESSARY TO CLEAR THIS FLAG OR JUST LEAVE IT TO CLEAR ON RESET)
				SJMP		EXIT_NEXT
NEXT_4_OPCODE:
				PUSH		DPH							; SAVE THE CONTENT OF THE DATA POINTER REGISTERS SINCE THEY WOULD BE USED HERE
				PUSH		DPL

				MOV			DPH, 3AH					; LOAD THE PREVIOUS ADDRESS INTO THE DATA POINTER
				MOV			DPL, 39H

				MOV			41H, DPH				   	; LOAD THE PREVIOUS ADDRESS INTO THE END ADDRESS WHICH PREPARE AN ADDRESS... 
				MOV			40H, DPL				   	; +1 GREATER THAN ITSELF FOR AUTO EXAM REG BY BOTH THE uC & uP AFTER 'END' IS PRESSED

				JB 			03H, NEXT_OPERAND			; SELECT BETWEEN OPERAND AND OPCODE NEXT CALL (OPCODE TYPE 03H= 0, OPERAND TYPE 03H= 1)

				; OPCODE NEXT CALL BEGINS HERE

				MOV			A, 33H						; TRANSFER THE OPCODE'S HEX CODE FROM BYTE 1 TEMPORARY STORE (ie 33H)
				MOVX		@DPTR, A					; INTO THE EXTERNAL MEMORY SPECIFIED BY THE USER.
				INC			DPTR						; INCREMENT THE DATA POINTER FOR THE NEXT INSTRUCTION'S EXTERNAL TRANSFER

				SJMP		EXIT_NEXT					; 'NEXT SR' CALL ENDS HERE FOR THE OPCODE
NEXT_OPERAND:
				; THE DATA TYPE OR BYTE 2 OPERAND BEGINS HERE
				
				MOV			41H, DPH				   	; LOAD THE PREVIOUS ADDRESS INTO THE END ADDRESS WHICH PREPARE AN ADDRESS... 
				MOV			40H, DPL				   	; +1 GREATER THAN ITSELF FOR AUTO EXAM REG BY BOTH THE uC & uP AFTER 'END' IS PRESSED

				MOV			A, 34H						; TRANSFER THE OPCODE'S HEX CODE FROM BYTE 2 TEMPORARY STORE (ie 34H)
				MOVX		@DPTR, A					; INTO THE EXTERNAL MEMORY SPECIFIED BY THE USER.
				INC			DPTR						; INCREMENT THE DATA POINTER FOR THE NEXT INSTRUCTION'S EXTERNAL TRANSFER

				JB			07H, NEXT_OPERAND_AD_TYPE	; SELECT BETWEEN DATA AND ADDRESS TYPE OPERAND
														; THE DATA TYPE CONTINUES WHILE ADDRESS TYPE JUMPS
				SJMP		EXIT_NEXT					; SR ENDS HERE FOR THE DATA TYPE OPERAND

NEXT_OPERAND_AD_TYPE:
				; ADDRESS TYPE COMPLETES THE REMAINING HALF (ie BYTE 3)
				MOV			41H, DPH				   	; LOAD THE PREVIOUS ADDRESS INTO THE END ADDRESS WHICH PREPARE AN ADDRESS... 
				MOV			40H, DPL				   	; +1 GREATER THAN ITSELF FOR AUTO EXAM REG BY BOTH THE uC & uP AFTER 'END' IS PRESSED

				MOV			A, 35H						; TRANSFER THE OPCODE'S HEX CODE FROM BYTE 3 TEMPORARY STORE (ie 35H)
				MOVX		@DPTR, A					; INTO THE EXTERNAL MEMORY SPECIFIED BY THE USER.
				INC			DPTR						; INCREMENT THE DATA POINTER FOR THE NEXT INSTRUCTION'S EXTERNAL TRANSFER

EXIT_NEXT:		; SAVE THE NEXT INSTRUCTION'S EXTERNAL TRANSFER ADDRESS (CURRENT ADDRESS)
				MOV			3AH, DPH					; LOAD THE HIGH ORDER BYTE
				MOV			39H, DPL					; LOAD THE LOWER ORDER BYTE

				MOV			43H, 3AH					; SAVE THE CURRENT ADDRESS IN THE PAGE MEMORY (HOB)
				MOV			42H, 39H					;											  (LOB)

				; DISPLAY THE NEW ADDRESS IN LINE 1 OF THE LCD (THE NEW ADDRESS ARE IN THE MEM LOC. 39H & 3AH)
				POP     	DPL							; RETRIEVE THE FORMER CONTENT OF THE DATA POINTER REGISTER
	       		POP     	DPH							; REMEMBER 'FIFO' TECHGNIQUE IS USED WHEN PUSHING AND POPPING ON THE STACK
				
				RET
									
; THIS SR IS CALL WHEN THE BEGIN ADDRESS IS TO BE ENTERED
; IT LOADS THE START ADDRESS INTO THE MEMORY ADDRESS INCREMENT DISPLAY REGISTER (THIS SHUOLD BE IN THE HEX FORM)

; ---------------------------------------------------------------------------------------------------------------------------------------
STEP:
				RET

; ---------------------------------------------------------------------------------------------------------------------------------------
SUB_MEM:		
				SETB		00H				; INDICATES THAT SUB MEM IS PRESSED THUS ENABLES THE PASS TO THE MAIN2 SEGMENT ON RETURN TO THE CALLER PROGRAM
				CLR			IE.7			; DISABLE THE EXTERNAL INTERRUPT(!INT0) USING THE GLOBAL IE BIT
 				CLR_LCD						; CLEAR THE LCD SCREEN

				MOV			A, #80H			; WRITE ON THE FIRST LINE OF THE LCD
				CALL		LCD_CMD			
				SETB		08H				; SET THE NEXT SUB MEM FLAG (SELECTS THE PART OF THE NEXT SR MEANT FOR SUB MEM) 
											; THE FLAG IS CLEARED IN THE NEXT SR (CHECK IF BIT 00H AND 08H FUNCTIONS CAN BE CO0MBINED IN ONE FLAGs)
				CALL		FLY_SUB_MEM		; TAKE CARE OF SUB MEM ADDRESS DISPLAY AND PROPER MEM START INITIALIZATION

				MOV			A, #84H			; LOAD A COMMAND TO DISPLAY ':' ON LINE 1, POSITION 5
				CALL		LCD_CMD
				MOV			A, #':'
				CALL		LCD_SHO

				SETB		IE.7			; NOW ENABLE THE EXTERNAL INTERRUPT

				RET

; ---------------------------------------------------------------------------------------------------------------------------------------
; VIEW HEXADECIMAL (V_HEX)
; THIS IS A SUBROUTINE THAT ENABLES THE USER TO VIEW THE HEXADECIMAL CODE OF THE ALREADY WRITTEN CODE
; BOTH IN MACHINE LANGUAGE AND IN ASMBELY LANGUAGE

; **** MAKE SURE YOU INCLUDE THE START AND END OF ADDRESS CHECKERS TO AVOID READ SUPERFULOUS CODES
; **** ALSO THE ADDRESS DISPLAY CONTROL OF THE SR
V_HEX:			MOV			3DH, 3FH					; LOAD THE START ADDRESS' HOB INTO THE V_HEX DISPLAY ADDRESS MEM LOC 2
				MOV			3CH, 3EH					; LOAD THE START ADDRESS' LOB INTO THE V_HEX DISPLAY ADDRESS MEM LOC 1

VH_1:			MOV			3AH, 3DH					; LOAD THE START ADDRESS (ON ENTRANCE TO THE SR) OR CURRENT ADDRESS (ON SR CONTINUITY)...
				MOV			39H, 3CH					; INTO ADDRESS_DISPLAY_CONTROL'S INPUT REGISTERS FOR DISPLAY
				CALL		ADDRESS_DISPLAY_CONTROL		; NOTE THE OSR CONTAINS THE MACRO 'CLR_LCD'

				MOV			DPH, 3DH					; LOAD THE START ADDRESS ON ENTRANCE TO THE SR OR... 
				MOV			DPL, 3CH					; CURRENT ADDRESS INTO THE DATA POINTER ON SR CONTINUITY

				MOVX		A, @DPTR					; RETRIEVE THE HEX CODE IN THE ADDRESS SPECIFIED BY THE CONTENT OF THE DPTR
				MOV			36H, A						; PLACE THE HEX CODE INTO THE INPUT MEMORY LOC. (36H) OF THE HEX_2_ASCII SR

				CALL		HEX_2_ASCII					; CALL THE OSR FOR CONVERSION

				MOV			A, #0C0H					; LOAD A COMMAND TO DISPLAY THE CONTENT OF 38H & 37H ON LINE 2, POSITION 1 & 2
				CALL		LCD_CMD

				MOV			A, 38H						; MOVE THE ASCII CODE OF THE HIGHER ORDER BYTE TO FOR DISPLAY
				CALL		LCD_SHO
				MOV			A, 37H						; MOVE THE ASCII CODE OF THE LOWER ORDER BYTE TO FOR DISPLAY
				CALL		LCD_SHO

VH_2:			CALL		KEYPAD_ID					; ENSURE A KEY IS DEPRESSED
				JNB			01H, VH_2
				CLR			01H	

; ***************SCROLL EITHER UP OR DOWN

				CJNE		A, #'6', VH_9 				; SCROLL UP
; A COMPARISON INSTRUCTION IS HERE TO DETERMINE WHETHER THE SCROLLING HAS ENDED OR NOT. THIS INVOLVES THE USE OF ...
; 2 DIFFERENT REGISTERS TO COMPARE ANOTHER 2 (SINCE ADDRESS IS A 16 BIT STUFF). MEM LOCS. INVOLVED: 3D&3CH AND START'S ADDRESS STORAGE MEM LOCS.
				MOV			A, 3DH
				CJNE		A, 3FH, VH_3				; COMPARE HOB OF CURRENT ADDRESS AND THAT OF START ADDRESS
				SETB		C			
VH_3:			JC			VH_4
				SJMP		VH_6						; PASSED. JUMP TO CONTINUE
				
VH_4:			MOV			A, 3CH
				CJNE		A, 3EH, VH_5				; COMPARE LOB OF CURRENT ADDRESS AND THAT OF START ADDRESS
				SETB		C
VH_5:			JC			VH_2						; THE 'SCROLL UP STOP' TEST ENDS HERE
														; PASSED. CONTINUE

VH_6:			JB			0BH, VH_7
				DJNZ		3CH, VH_8					; DECREMENT THE ADDRESS (16 BITS OR 2 BYTES) FOR THE NEXT CODE AND...
VH_7:			CPL			0BH							; HELPS TO MONITOR DECREMENT ON OVERFLOW
				JB			0BH, VH_8
				DEC			3DH							; (THIS ADDRESS DECREMENT IS A I6 BIT OR 2 BYTE DECREMENTING SO OBSERVE CAREFULLY)
				MOV			3CH, #0FFH

VH_8:			MOV			DPH, 3DH					; LOAD THE START/CURRENT ADDRESS INTO THE DATA POINTER
				MOV			DPL, 3CH

				SJMP		VH_1						; GO BACK AND START AFRESH WITH THE THE NEW(PREVIOUS) ADDRESS

VH_9:			CJNE		A, #'7', VH_14 				; SCROLL DOWN
; A COMPARISON INSTRUCTION HERE TO DETERMINE WHETHER THE SCROLLING HAS ENDED OR NOT. THIS MAY INVOLVE THE USE OF ...
; 2 DIFFERENT REGISTERS TO COMPARE ANOTHER 2 (SINCE ADDRESS IS A 16 BIT STUFF). REGSITERS INVOLVED: 3D&3CH AND END'S ADDRESS STORAGE MEM LOC.
				MOV			A, 3DH
				CJNE		A, 41H, VH_10				; COMPARE HOB OF CURRENT ADDRESS AND THAT OF END ADDRESS
				CLR			C			
VH_10:			JNC			VH_11
				SJMP		VH_13						; PASSED. JUMP TO CONTINUE
				
VH_11:			MOV			A, 3CH
				CJNE		A, 40H, VH_12				; COMPARE LOB OF CURRENT ADDRESS AND THAT OF END ADDRESS
				CLR			C
VH_12:			JNC			VH_2						; THE 'SCROLL DOWN STOP' TEST ENDS HERE
														; PASSED. CONTINUE

VH_13:			INC			DPTR						; INCREMENT THE ADDRESS FOR THE NEXT CODE
				MOV			3DH, DPH					; LOAD THE START/CURRENT ADDRESS INTO THE DATA POINTER
				MOV			3CH, DPL

				SJMP		VH_1						; GO BACK AND START AFRESH WITH THE THE NEW(NEXT) ADDRESS

VH_14:			CJNE		A, #'5', VH_2 				; JUMP TO A USER SPECIFIED ADDRESS
				CALL		GO_TO						; GO TO THE USER ADDRESS
				SJMP		VH_1						; GO BACK AND START AFRESH WITH THE THE NEW(NEXT) ADDRESS
			   ; U MAY INCLUDE A SKIP IN THE GOTO OSR WHEN CANCEL IS PRESS TO COME ON THIS LINE. PUT ON THIS LINE INSTRUCTIONS TO GO BACK AT ITS FORMER ADDRESS

; TESTED: QC PASSED SYNTAXICALLY

; ---------------------------------------------------------------------------------------------------------------------------------------
ROW_1: 				DB 			'0','1','2','3','4','5','6','7'		; DATA STORED IN ASCII CODE
ROW_2: 				DB 			'E','R','T','U','I','O','P','8'
ROW_3: 				DB 			'A','S','D','F','H','J','L','9'
ROW_4: 				DB 			'Z','X','C','V','B','N','M','*'		; '*' IS RESERVED FOR THE FUNCTION 'NEXT'

					END