___FLY_11BIT_ADDRESS:
; THIS A SR THAT ASSEMBLES CORRECTLY THE CODE 
; FOR 'ABSOLUTE' (eg AJMP) INSTRUCTION SET
; MEMORY LOCATION USED IN THIS SR ARE: 32H
					
					MOV			32H, #04H					; ENSURES THAT ONLY FOUR NIBBLES (ie 2 BYTE DATA) ARE ENTERED
					SETB		04H							; SET THE BYTE INDICATOR FOR A 2 BYTE(4 NIBBLE) OPERAND CONVERSION
					SETB		06H							; SET FLAG TO CAUSE THE ASCII_2_HEX SR TO CARRY OUT HIGH ORDER BYTE MARRIAGE FIRST

___F11BA_1:			CALL		KEYPAD_ID
					JNB			01H, ___F11BA_1
					CLR			01H							; GET READY FOR NEXT KEY

					CALL		ASCII_2_HEX					; DO THE CONVERSION
					JNB			02H, ___F11BA_1				; ENSURES THAT THE KEY PRESSED IS BETWEEN 0 - F IN HEX
					CLR			02H							; GET READY FOR NEXT KEY

					MOV 		A,31H						; DISPLAY THE NUMBER
					CALL		LCD_SHO
					DJNZ		32H, ___F11BA_1				; CHECK IF FOUR NIBBLES (TWO BYTES) DATA HAVE BEEN ENTERED
					; THE RESULT OF THE CONVERSION WOULD BE IN 35H(HIGHER) & 34H(LOWER) BYTES

					; MASK SOME OF THE BITS IN THE HIGHER ORDER BYTE TO GET ONLY A10, A9 & A8.
					MOV			A, 35H
					ANL			A, #00000111B				; ONLY A10, A9 & A8	VALUES WOULD BE RETAINED; OTHERS = 0
					RR			A							; ROTATE TO POSITION THEM AS A10,A9,A8,0,0,0,0,0
					RR			A
					RR			A
					ORL			33H, A						; SAVE THE FINAL ANSWER	IN 33H
					CALL		FLY_OPCODE_SKIP				; JUST TO LOAD THE OPCODE ONLY
					; NOTICE THAT THIS SR HAS NO SEPARATE INSTRUCTIONS THAT ENSURES THE USER PRESSES THE 'NEXT KEY' ie '*'
					; THIS IS BECAUSE IN THE SR JUST ABOVE (FLY_OPCODE_SKIP) HAS THOSE INSTRUCTIONS ALREADY
					SETB		03H							; SELECT OPERAND TYPE IN THE 'NEXT SR' (NOT OPCODE TYPE)
					SETB		0EH							; SELECT ADDRESS TYPE OPERAND IN THE 'NEXT SR' FOR 8051 ONLY
					CALL		NEXT						; CALL NEXT OSR TO PERMANENTLY SAVE THE OPERAND CODES

					MOV			43H, 3AH					; SAVE THE CURRENT ADDRESS IN THE PAGE MEMORY (HOB)
					MOV			42H, 39H					;											  (LOB)

					CALL		ADDRESS_DISPLAY_CONTROL		; CALL THIS OSR TO CLEAR THE LCD SCREEN AND WRITE THE NEW ADDRESS IN LINE 1

					RET	