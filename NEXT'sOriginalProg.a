; THIS SUBROUTINE LOADS THE APPROPRIATE OPCODE OR OPERAND(ie DATA OR ADDRESS) INTO THEIR PERMANENT LOCATION
; IT DIFFRENETIATES OPCODE CALL FROM AN OPERAND CALL BY USING THE NEXT TYPE FLAG (ie NCF 03H)
; WHEN IT IS SET IT CALLS THE OPERAND ELSE THE OPCODE, NCF IS TESTED AT THE ENTRANCE TO THE SR 
; IT ALSO HANDLES THE SUB MEM START ADDRESS INTIALIZATION 

; THIS IS THE SR WHERE MEMORY ADDRESS INCREMENT DISPLAY REGISTER IS TO BE CONFIGURED
; ***ON ERROR AFTER TESTING THIS SR CHANGE DPH = 83H, & DPL = 82H(DIRECT ADDRESSING)

; ****REMEMBER TO SAVE REGS & FLAGS STILL RELEVANT TO THE CALLER PROGRAM TO AVOID DATA LOSS****

NEXT:			

				JB			08H, NEXT_4_SUB_MEM		   	; CHECK WHETHER CALLER PROGRAM IS SUB MEM OR OTHERS AND JUMP APTLY
				SJMP		NEXT_4_OPCODE
NEXT_4_SUB_MEM:
				; LOAD THE USER'S DESIRED START CODE ADDRESS IN THE DATA POINTER'S HIGH AND LOWER ORDER REG.
				

				MOV			3AH, 35H					; LOAD THE HIGH ORDER BYTE INTO NEXT ADDRESS HOLDER/ADDRESS_DISPLAY_CONTROL'S INPUT MEM LOC 2 FOR DISPLAY 
				MOV			39H, 34H					; LOAD THE LOW ORDER BYTE INTO NEXT ADDRESS HOLDER/ADDRESS_DISPLAY_CONTROL'S INPUT MEM LOC 1 FOR DISPLAY

				MOV			3FH, 35H					; LOAD THE HIGH ORDER BYTE INTO THE V_HEX DISPLAY ADDRESS MEM LOC 2
				MOV			3EH, 34H					; LOAD THE LOWER ORDER BYTE	INTO THE V_HEX DISPLAY ADDRESS MEM LOC 1

				; THE MEM. LOCATIONS TO BE USED HERE ARE 34H & 35H (BECAUSE THEY CONTAIN THE CURRENT LOW & HIGH ORDER ADDRESS RESPECTIVELY)
				; LOAD IT INTO A REGISTER (EXTERNAL TRANSFER REGISTER) THAT CAN COMMUNICATE WITH THE OUTSIDE WORLD(I MEAN OUTSIDE THE MICROCONTROLLER)

				CLR			08H							; CLEAR THE NEXT SUB MEM FLAG (IS IT NECESSARY TO CLEAR THIS FLAG OR JUST LEAVE IT TO CLEAR ON RESET)
				SJMP		EXIT_NEXT
NEXT_4_OPCODE:
				PUSH		DPH							; SAVE THE CONTENT OF THE DATA POINTER REGISTERS SINCE THEY WOULD BE USED HERE
				PUSH		DPL

				JB 			03H, NEXT_OPERAND			; SELECT BETWEEN OPERAND AND OPCODE NEXT CALL (OPCODE TYPE 03H= 0, OPERAND TYPE 03H= 1)

				; OPCODE NEXT CALL BEGINS HERE
				MOV			DPH, 3AH					; LOAD THE PREVIOUS ADDRESS INTO THE DATA POINTER
				MOV			DPL, 39H

				MOV			A, 33H						; TRANSFER THE OPCODE'S HEX CODE FROM BYTE 1 TEMPORARY STORE (ie 33H)
				MOVX		@DPTR, A					; INTO THE EXTERNAL MEMORY SPECIFIED BY THE USER.
				INC			DPTR						; INCREMENT THE DATA POINTER FOR THE NEXT INSTRUCTION'S EXTERNAL TRANSFER

				; SAVE THE NEXT INSTRUCTION'S EXTERNAL TRANSFER ADDRESS
				MOV			3AH, DPH					; LOAD THE HIGH ORDER BYTE
				MOV			39H, DPL					; LOAD THE LOWER ORDER BYTE


				SJMP		EXIT_NEXT					; 'NEXT SR' CALL ENDS HERE FOR THE OPCODE
NEXT_OPERAND:
				; THE DATA TYPE OR BYTE 2 OPERAND BEGINS HERE
				
				MOV			DPH, 3AH					; LOAD THE PREVIOUS ADDRESS INTO THE DATA POINTER
				MOV			DPL, 39H

				MOV			A, 34H						; TRANSFER THE OPCODE'S HEX CODE FROM BYTE 2 TEMPORARY STORE (ie 34H)
				MOVX		@DPTR, A					; INTO THE EXTERNAL MEMORY SPECIFIED BY THE USER.
				INC			DPTR						; INCREMENT THE DATA POINTER FOR THE NEXT INSTRUCTION'S EXTERNAL TRANSFER

				JB			07H, NEXT_OPERAND_AD_TYPE	; SELECT BETWEEN DATA AND ADDRESS TYPE OPERAND
														; THE DATA TYPE CONTINUES WHILE ADDRESS TYPE JUMPS
				; SAVE THE NEXT INSTRUCTION'S EXTERNAL TRANSFER ADDRESS (CURRENT ADDRESS)
				MOV			3AH, DPH					; LOAD THE HIGH ORDER BYTE
				MOV			39H, DPL					; LOAD THE LOWER ORDER BYTE

				SJMP		EXIT_NEXT					; SR ENDS HERE FOR THE DATA TYPE OPERAND

NEXT_OPERAND_AD_TYPE:
				; ADDRESS TYPE COMPLETES THE REMAINING HALF (ie BYTE 3)
				MOV			A, 35H						; TRANSFER THE OPCODE'S HEX CODE FROM BYTE 3 TEMPORARY STORE (ie 35H)
				MOVX		@DPTR, A					; INTO THE EXTERNAL MEMORY SPECIFIED BY THE USER.
				INC			DPTR						; INCREMENT THE DATA POINTER FOR THE NEXT INSTRUCTION'S EXTERNAL TRANSFER

				; SAVE THE NEXT INSTRUCTION'S EXTERNAL TRANSFER ADDRESS (CURRENT ADDRESS)
				MOV			3AH, DPH					; LOAD THE HIGH ORDER BYTE
				MOV			39H, DPL					; LOAD THE LOWER ORDER BYTE

EXIT_NEXT:
				; DISPLAY THE NEW ADDRESS IN LINE 1 OF THE LCD (THE NEW ADDRESS ARE IN THE MEM LOC. 39H & 3AH)
				POP     	DPL							; RETRIEVE THE FORMER CONTENT OF THE DATA POINTER REGISTER
	       		POP     	DPH							; REMEMBER 'FIFO' TECHGNIQUE IS USED WHEN PUSHING AND POPPING ON THE STACK
				
				RET




; INCLUDE AN INSTRUCTION TO INCREMENT THE ADDRESS DISPLAYED BY 1 AND AT THE SAME TIME CHECK FOR OVERFLOW
; THUS THERE WOULD BE TWO REGISTERS HANDLING THIS 
; 1) THE HIGH ORDER BYTE 2) THE LOWER ORDER BYTE ADDRESS DISPLAY MEM. LOCS. OR REGS.
; INCLUDE AN INSTRUCTION THAT DISPLAYS THE CURRENT ADDRESS ON LINE 1


				; INCLUDE AN INSTRUCTION TO INCREMENT THE ADDRESS DISPLAYED BY 1(1 BYTE OPERAND) AND AT THE SAME TIME CHECK FOR OVERFLOW
				; THUS THERE WOULD BE TWO REGISTERS HANDLING THIS 1) FOR THE HIGH ORDER BYTE 2) FOR THE LOWER ORDER BYTE
				; THE INCREMENT FOR THE EXTERNAL TRANSFER REGISTER SHOULD BY 1
				; INCLUDE AN INSTRUCTION THAT DISPLAYS THE CURRENT ADDRESS ON LINE 1
				; THERE SHOULD BE A CHECK FLAG (WE CAN STILL USE MEM BIT LOC. 07H) TO SKIP THE DISPLAY CONTROL OF THIS SR SEGMENT IF THE CALLER PROGRAM IS NOT DATA TYPE OPERAND

; INCLUDE AN INSTRUCTION TO INCREMENT THE ADDRESS DISPLAYED BY 2(2 BYTE OPERAND) AND AT THE SAME TIME CHECK FOR OVERFLOW
				; THUS THERE WOULD BE TWO REGISTERS HANDLING THIS 1) FOR THE HIGH ORDER BYTE 2) FOR THE LOWER ORDER BYTE
				; THE INCREMENT FOR THE EXTERNAL TRANSFER REGISTER SHOULD BY 1
				; INCLUDE AN INSTRUCTION THAT DISPLAYS THE CURRENT ADDRESS ON LINE 1

